"""
SpecFlow V2.0 - æ‰©å±•æ–‡æ¡£ç”Ÿæˆå™¨
åŒ…å«å®æ–½è®¡åˆ’,é£é™©è¯„ä¼°,è´¨é‡æŠ¥å‘Šç”Ÿæˆå™¨å’Œä¸»ç”Ÿæˆå™¨
ç‰ˆæœ¬: 2.0.0
"""

from typing import List, Dict, Any, Optional, Tuple, Union, Callable
from datetime import datetime, timedelta

from generator import BaseGenerator
from atomic_component import AtomicComponent, UserStory, Feature
from models_v2 import (
    SpecificationV2, Document, DocumentType, DocumentStatus,
    DepthLevel, QualityMetrics, Risk, Milestone,
    WorkBreakdownStructure
)
from config_v2 import SpecFlowConfigV2
from validators import QualityValidator


# ============ å®æ–½è®¡åˆ’ç”Ÿæˆå™¨ ============

class ImplementationPlanGenerator(BaseGenerator):
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    04-å®æ–½è®¡åˆ’ ç”Ÿæˆå™¨

    def generate(self) -> Document:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆå®æ–½è®¡åˆ’æ–‡æ¡£
        content = {
            "wbs": self._generate_wbs(),
            "milestones": self._generate_milestones(),
            "timeline": self._generate_timeline(),
            "resource_plan": self._generate_resource_plan()
        }

        return self._create_document(
            DocumentType.IMPLEMENTATION,
            f"{self.spec.project_name} - å®æ–½è®¡åˆ’",
            content,
            self._get_token_budget(DocumentType.IMPLEMENTATION)
        )

    def _generate_wbs(self) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆå·¥ä½œåˆ†è§£ç»“æ„
        wbs = "## å·¥ä½œåˆ†è§£ç»“æ„(WBS)\n\n"

        if self.spec.wbs:
            for phase_wbs in self.spec.wbs:
                wbs += f"### é˜¶æ®µ: {phase_wbs.phase}\n\n"
                wbs += f"**ä¼°ç®—å·¥æ—¶**: {phase_wbs.estimated_hours:.1f} å°æ—¶\n\n"

                if phase_wbs.features:
                    wbs += "**ç‰¹æ€§**:\n"
                    for feature in phase_wbs.features[:5]:
                        wbs += f"- {feature.name} ({feature.estimated_hours:.1f}h)\n"
                    wbs += "\n"

                wbs += "---\n\n"
        else:
            # ä»ç»„ä»¶ç”Ÿæˆç®€å•çš„ WBS
            wbs += "### MVP é˜¶æ®µ\n\n"

            # æŒ‰åˆ†ç±»åˆ†ç»„ç»„ä»¶
            categories = {}
            for component in self.spec.components:
                cat = component.category.value
                if cat not in categories:
                    categories[cat] = []
                categories[cat].append(component)

            for cat, components in list(categories.items())[:4]:
                wbs += f"#### {cat}\n\n"
                total_hours = sum(c.estimated_hours for c in components)
                wbs += f"**æ€»å·¥æ—¶**: {total_hours:.1f} å°æ—¶\n\n"

                for component in components[:5]:
                    wbs += f"- {component.name} ({component.estimated_hours:.1f}h)\n"
                wbs += "\n"

        return wbs

    def _generate_milestones(self) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆé‡Œç¨‹ç¢‘
        milestones = "## é‡Œç¨‹ç¢‘\n\n"

        if self.spec.milestones:
            for milestone in self.spec.milestones:
                milestones += f"### {milestone.name}\n\n"
                milestones += f"**é¢„è®¡å®Œæˆ**: {milestone.estimated_date}\n\n"
                milestones += "**äº¤ä»˜ç‰©**:\n"
                for deliverable in milestone.deliverables:
                    milestones += f"- {deliverable}\n"
                milestones += "\n---\n\n"
        else:
            # ç”Ÿæˆé»˜è®¤é‡Œç¨‹ç¢‘
            milestones += "### M1: MVP å‘å¸ƒ\n\n"
            milestones += "**é¢„è®¡å®Œæˆ**: 3 ä¸ªæœˆå\n\n"
            milestones += "**äº¤ä»˜ç‰©**:\n- æ ¸å¿ƒåŠŸèƒ½\n- åŸºç¡€æµ‹è¯•\n\n"

        return milestones

    def _generate_timeline(self) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆæ—¶é—´çº¿
        timeline = "## é¡¹ç›®æ—¶é—´çº¿\n\n"
        timeline += "```\n"
        timeline += "Phase 1 (MVP)     : â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ (0-3æœˆ)\n"
        timeline += "Phase 2 (æ‰©å±•)    : â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ (3-6æœˆ)\n"
        timeline += "Phase 3 (ä¼˜åŒ–)    : â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆ (6-9æœˆ)\n"
        timeline += "```\n\n"
        return timeline

    def _generate_resource_plan(self) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆèµ„æºè®¡åˆ’
        resource = "## èµ„æºè®¡åˆ’\n\n"
        resource += "| è§’è‰² | äººæ•° | æŠ€èƒ½è¦æ±‚ |\n"
        resource += "|------|------|----------|\n"
        resource += "| å‰ç«¯å¼€å‘ | 2 | React, TypeScript |\n"
        resource += "| åç«¯å¼€å‘ | 3 | Node.js / Python |\n"
        resource += "| æµ‹è¯•å·¥ç¨‹å¸ˆ | 1 | è‡ªåŠ¨åŒ–æµ‹è¯• |\n"
        resource += "| DevOps | 1 | AWS, Docker, K8s |\n\n"
        return resource

    def _dict_to_markdown(self, content: Dict[str, Any]) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è½¬æ¢ä¸º Markdown
        md = f"# {self.spec.project_name} - å®æ–½è®¡åˆ’\n\n"
        md += f"**ç‰ˆæœ¬**: {self.spec.project_version}\n"
        md += f"**ç”Ÿæˆæ—¶é—´**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        md += "---\n\n"

        for section_content in content.values():
            md += section_content

        return md


# ============ é£é™©è¯„ä¼°ç”Ÿæˆå™¨ ============

class RiskAssessmentGenerator(BaseGenerator):
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    06-é£é™©è¯„ä¼° ç”Ÿæˆå™¨

    def generate(self) -> Document:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆé£é™©è¯„ä¼°æ–‡æ¡£
        content = {
            "risk_matrix": self._generate_risk_matrix(),
            "risk_details": self._generate_risk_details(),
            "mitigation_plan": self._generate_mitigation_plan()
        }

        return self._create_document(
            DocumentType.RISK_ASSESSMENT,
            f"{self.spec.project_name} - é£é™©è¯„ä¼°",
            content,
            self._get_token_budget(DocumentType.RISK_ASSESSMENT)
        )

    def _generate_risk_matrix(self) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆé£é™©çŸ©é˜µ
        matrix = "## é£é™©çŸ©é˜µ\n\n"
        matrix += "```\n"
        matrix += "å½±å“ â†‘\n"
        matrix += "é«˜  â”‚  ğŸŸ¡   ğŸ”´   ğŸ”´  \n"
        matrix += "ä¸­  â”‚  ğŸŸ¢   ğŸŸ¡   ğŸ”´  \n"
        matrix += "ä½  â”‚  ğŸŸ¢   ğŸŸ¢   ğŸŸ¡  \n"
        matrix += "    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ æ¦‚ç‡\n"
        matrix += "       ä½   ä¸­   é«˜\n"
        matrix += "```\n\n"
        return matrix

    def _generate_risk_details(self) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆé£é™©è¯¦æƒ…
        details = "## é£é™©è¯¦æƒ…\n\n"

        if self.spec.risks:
            for risk in self.spec.risks:
                details += f"### {risk.id}: {risk.title}\n\n"
                details += f"**ç±»åˆ«**: {risk.category}\n"
                details += f"**æ¦‚ç‡**: {risk.probability}\n"
                details += f"**å½±å“**: {risk.impact}\n"
                details += f"**ä¸¥é‡ç¨‹åº¦**: {risk.severity.value}\n\n"
                details += f"**æè¿°**: {risk.description}\n\n"
                details += f"**ç¼“è§£æªæ–½**: {risk.mitigation}\n\n"
                details += "---\n\n"
        else:
            # ç”Ÿæˆé»˜è®¤é£é™©
            details += "### RISK-001: æŠ€æœ¯é£é™©\n\n"
            details += "**æè¿°**: æ–°æŠ€æœ¯æ ˆå­¦ä¹ æ›²çº¿\n\n"
            details += "**ç¼“è§£**: æä¾›åŸ¹è®­å’ŒæŠ€æœ¯æ”¯æŒ\n\n"

        return details

    def _generate_mitigation_plan(self) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆç¼“è§£è®¡åˆ’
        plan = "## ç¼“è§£è®¡åˆ’\n\n"
        plan += "| é£é™©ID | ç¼“è§£æªæ–½ | è´£ä»»äºº | æ—¶é—´è¡¨ |\n"
        plan += "|--------|---------|--------|--------|\n"

        if self.spec.risks:
            for risk in self.spec.risks[:10]:
                owner = risk.owner if risk.owner else "å¾…å®š"
                plan += f"| {risk.id} | {risk.mitigation[:50]}... | {owner} | æŒç»­ |\n"
        else:
            plan += "| å¾…å®š | å¾…å®š | å¾…å®š | å¾…å®š |\n"

        plan += "\n"
        return plan

    def _dict_to_markdown(self, content: Dict[str, Any]) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è½¬æ¢ä¸º Markdown
        md = f"# {self.spec.project_name} - é£é™©è¯„ä¼°\n\n"
        md += f"**ç‰ˆæœ¬**: {self.spec.project_version}\n"
        md += f"**ç”Ÿæˆæ—¶é—´**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        md += "---\n\n"

        for section_content in content.values():
            md += section_content

        return md


# ============ è´¨é‡æŠ¥å‘Šç”Ÿæˆå™¨ ============

class QualityReportGenerator(BaseGenerator):
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    07-è´¨é‡æŠ¥å‘Š ç”Ÿæˆå™¨

    def generate(self) -> Document:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆè´¨é‡æŠ¥å‘Šæ–‡æ¡£
        content = {
            "quality_summary": self._generate_quality_summary(),
            "validation_results": self._generate_validation_results(),
            "improvement_recommendations": self._generate_recommendations()
        }

        return self._create_document(
            DocumentType.QUALITY_REPORT,
            f"{self.spec.project_name} - è´¨é‡æŠ¥å‘Š",
            content,
            self._get_token_budget(DocumentType.QUALITY_REPORT)
        )

    def _generate_quality_summary(self) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆè´¨é‡æ‘˜è¦
        summary = "## è´¨é‡æ‘˜è¦\n\n"

        if self.spec.quality_metrics:
            qm = self.spec.quality_metrics
            summary += f"### æ€»ä½“è¯„çº§: {qm.overall_grade.value}\n\n"
            summary += "| ç»´åº¦ | å¾—åˆ† | ç›®æ ‡ | çŠ¶æ€ |\n"
            summary += "|------|------|------|------|\n"
            summary += f"| å®Œæ•´æ€§ | {qm.completeness_score:.1f} | â‰¥ 95 | {'' if qm.completeness_score >= 95 else ''} |\n"
            summary += f"| ä¸€è‡´æ€§ | {qm.consistency_score:.1f} | 100 | {'' if qm.consistency_score == 100 else ''} |\n"
            summary += f"| åŸå­æ€§ | {qm.atomicity_score:.1f} | â‰¥ 90 | {'' if qm.atomicity_score >= 90 else ''} |\n"
            summary += f"| å¯è¡Œæ€§ | {qm.feasibility_score:.1f} | â‰¥ 90 | {'' if qm.feasibility_score >= 90 else ''} |\n\n"
        else:
            summary += "è´¨é‡æŒ‡æ ‡å¾…è®¡ç®—\n\n"

        return summary

    def _generate_validation_results(self) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”ŸæˆéªŒè¯ç»“æœ
        results = "## éªŒè¯ç»“æœ\n\n"

        if self.spec.validation_issues:
            # æŒ‰ä¸¥é‡ç¨‹åº¦åˆ†ç»„
            critical = [i for i in self.spec.validation_issues if i.severity.value == "Critical"]
            high = [i for i in self.spec.validation_issues if i.severity.value == "High"]
            medium = [i for i in self.spec.validation_issues if i.severity.value == "Medium"]

            results += f"### é—®é¢˜ç»Ÿè®¡\n\n"
            results += f"- ğŸ”´ å…³é”®é—®é¢˜: {len(critical)}\n"
            results += f"- ğŸŸ¡ é«˜ä¼˜å…ˆçº§: {len(high)}\n"
            results += f"- ğŸŸ¢ ä¸­ä¼˜å…ˆçº§: {len(medium)}\n\n"

            if critical:
                results += "### ğŸ”´ å…³é”®é—®é¢˜\n\n"
                for issue in critical[:5]:
                    results += f"- **{issue.description}**\n"
                    results += f"  - ä½ç½®: {issue.location}\n"
                    results += f"  - å»ºè®®: {issue.suggestion}\n\n"
        else:
            results += " æœªå‘ç°éªŒè¯é—®é¢˜\n\n"

        return results

    def _generate_recommendations(self) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆæ”¹è¿›å»ºè®®
        recommendations = "## æ”¹è¿›å»ºè®®\n\n"

        if self.spec.quality_metrics:
            qm = self.spec.quality_metrics

            if qm.completeness_score < 95:
                recommendations += "### å®Œæ•´æ€§æ”¹è¿›\n\n"
                recommendations += "- è¡¥å……ç¼ºå¤±çš„ç»„ä»¶å®šä¹‰\n"
                recommendations += "- å®Œå–„ç”¨æˆ·æ•…äº‹å’ŒéªŒæ”¶æ ‡å‡†\n\n"

            if qm.consistency_score < 100:
                recommendations += "### ä¸€è‡´æ€§æ”¹è¿›\n\n"
                recommendations += "- ç»Ÿä¸€æœ¯è¯­ä½¿ç”¨\n"
                recommendations += "- è§£å†³æ¥å£å†²çª\n\n"

            if qm.atomicity_score < 90:
                recommendations += "### åŸå­æ€§æ”¹è¿›\n\n"
                recommendations += "- ç»†åŒ–ç»„ä»¶ç²’åº¦\n"
                recommendations += "- è¡¥å……è¾¹ç•Œæƒ…å†µå¤„ç†\n\n"

        if not recommendations.count("###"):
            recommendations += " è§„æ ¼è´¨é‡ä¼˜ç§€,æ— éœ€æ”¹è¿›\n\n"

        return recommendations

    def _dict_to_markdown(self, content: Dict[str, Any]) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è½¬æ¢ä¸º Markdown
        md = f"# {self.spec.project_name} - è´¨é‡æŠ¥å‘Š\n\n"
        md += f"**ç‰ˆæœ¬**: {self.spec.project_version}\n"
        md += f"**ç”Ÿæˆæ—¶é—´**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        md += "---\n\n"

        for section_content in content.values():
            md += section_content

        return md


# ============ ä¸»è§„æ ¼ç”Ÿæˆå™¨(ç¼–æ’å™¨) ============

class SpecificationGenerator:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    ä¸»è§„æ ¼ç”Ÿæˆå™¨
    ç¼–æ’æ‰€æœ‰æ–‡æ¡£ç”Ÿæˆå™¨,ç”Ÿæˆå®Œæ•´çš„ V2.0 è§„æ ¼æ–‡æ¡£é›†
    """

    def __init__(self, config: Dict[str, Any]):
        """å¾…æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²"""
        self.config = config
        self.depth_level = DepthLevel(config.get("depth_level", "standard"))

    def generate(
        """å¾…æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²"""
        self,
        project_name: str,
        task_description: str,
        analysis_result: Any,  # TaskAnalysisResult
        components: List[AtomicComponent],
        user_stories: List[UserStory],
        features: List[Feature]
    ) -> SpecificationV2:
        """
        ç”Ÿæˆå®Œæ•´çš„è§„æ ¼æ–‡æ¡£é›†

        Args:
            project_name: é¡¹ç›®åç§°
            task_description: ä»»åŠ¡æè¿°
            analysis_result: ä»»åŠ¡åˆ†æç»“æœ
            components: åŸå­ç»„ä»¶åˆ—è¡¨
            user_stories: ç”¨æˆ·æ•…äº‹åˆ—è¡¨
            features: ç‰¹æ€§åˆ—è¡¨

        Returns:
            SpecificationV2: å®Œæ•´çš„è§„æ ¼æ–‡æ¡£é›†
        """

        # 1. åˆ›å»ºè§„æ ¼å¯¹è±¡
        spec = SpecificationV2(
            project_name=project_name,
            project_version="1.0.0",
            depth_level=self.depth_level,
            components=components,
            user_stories=user_stories,
            features=features
        )

        # 2. æ ¹æ®æ·±åº¦çº§åˆ«ç¡®å®šè¦ç”Ÿæˆçš„æ–‡æ¡£
        multi_doc_config = SpecFlowConfigV2.MULTI_DOC_CONFIGS.get(
            self.depth_level.value,
            SpecFlowConfigV2.MULTI_DOC_CONFIGS["standard"]
        )

        required_documents = multi_doc_config["documents"]

        # 3. ç”Ÿæˆæ¯ä¸ªæ–‡æ¡£
        generators_map = {
            DocumentType.OVERVIEW: OverviewGenerator,
            DocumentType.REQUIREMENTS: RequirementsGenerator,
            DocumentType.DOMAIN_MODEL: DomainModelGenerator,
            DocumentType.ARCHITECTURE: ArchitectureGenerator,
            DocumentType.IMPLEMENTATION: ImplementationPlanGenerator,
            DocumentType.TEST_STRATEGY: TestStrategyGenerator,
            DocumentType.RISK_ASSESSMENT: RiskAssessmentGenerator,
            DocumentType.QUALITY_REPORT: QualityReportGenerator
        }

        # éœ€è¦å…ˆå¯¼å…¥è¿™äº›ç”Ÿæˆå™¨ç±»(åœ¨å®é™…ä½¿ç”¨æ—¶)
        from generator import (
            OverviewGenerator, RequirementsGenerator,
            DomainModelGenerator, ArchitectureGenerator,
            TestStrategyGenerator
        )

        for doc_type in required_documents:
            generator_class = generators_map.get(doc_type)
            if generator_class:
                generator = generator_class(spec, self.config)
                document = generator.generate()
                spec.add_document(document)

        # 4. è¿è¡Œè´¨é‡éªŒè¯
        quality_metrics = QualityValidator.validate_specification(spec, multi_doc_config)
        spec.quality_metrics = quality_metrics

        # 5. æ›´æ–°è§„æ ¼çŠ¶æ€
        spec.updated_at = datetime.now().isoformat()

        return spec

    def save_specification(self, spec: SpecificationV2, output_dir: str):
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ä¿å­˜è§„æ ¼æ–‡æ¡£åˆ°æ–‡ä»¶ç³»ç»Ÿ

        Args:
            spec: è§„æ ¼å¯¹è±¡
            output_dir: è¾“å‡ºç›®å½•
        """
        import os

        # åˆ›å»ºé¡¹ç›®ç›®å½•
        project_dir = os.path.join(output_dir, f"{spec.project_name}-specs")
        os.makedirs(project_dir, exist_ok=True)

        # ä¿å­˜æ¯ä¸ªæ–‡æ¡£
        for doc_type, document in spec.documents.items():
            filename = f"{doc_type.value}.md"
            filepath = os.path.join(project_dir, filename)

            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(document.markdown)

        # ä¿å­˜ç´¢å¼•æ–‡ä»¶
        index_file = os.path.join(project_dir, "README.md")
        with open(index_file, 'w', encoding='utf-8') as f:
            f.write(spec.to_markdown_index())

        print(f" è§„æ ¼æ–‡æ¡£å·²ä¿å­˜åˆ°: {project_dir}")
        print(f"   - {len(spec.documents)} ä¸ªæ–‡æ¡£")
        print(f"   - æ€» Token: {spec.get_total_tokens():,}")
        print(f"   - è´¨é‡ç­‰çº§: {spec.quality_metrics.overall_grade.value if spec.quality_metrics else 'N/A'}")


# Error handling example
try:
    pass
except Exception:
    pass
