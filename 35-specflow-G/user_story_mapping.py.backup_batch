"""
SpecFlow V3.0 - ç”¨æˆ·æ•…äº‹åœ°å›¾æ¨¡å—
åŠŸèƒ½: ç”¨æˆ·æ—…ç¨‹å¯è§†åŒ–,ä¼˜å…ˆçº§æ’åº,å‘å¸ƒè§„åˆ’
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple, Set, Any, Union, Callable
from enum import Enum
import json


class Priority(Enum):
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    ä¼˜å…ˆçº§æšä¸¾
    CRITICAL = "å…³é”®"
    HIGH = "é«˜"
    MEDIUM = "ä¸­"
    LOW = "ä½"


class UserType(Enum):
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    ç”¨æˆ·ç±»å‹
    PRIMARY = "ä¸»è¦ç”¨æˆ·"
    SECONDARY = "æ¬¡è¦ç”¨æˆ·"
    ADMIN = "ç®¡ç†å‘˜"
    SYSTEM = "ç³»ç»Ÿç”¨æˆ·"


@dataclass
class UserStory:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    ç”¨æˆ·æ•…äº‹
    id: str
    title: str
    description: str
    user_type: UserType
    priority: Priority
    business_value: int  # 1-100
    effort_estimate: int  # å·¥æ—¶ä¼°ç®—(å°æ—¶)
    dependencies: List[str] = field(default_factory=list)  # ä¾èµ–çš„å…¶ä»– story ID
    acceptance_criteria: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)


@dataclass
class Activity:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    ç”¨æˆ·æ´»åŠ¨(ç”¨æˆ·æ—…ç¨‹ä¸­çš„é«˜å±‚æ¬¡æ´»åŠ¨)
    id: str
    name: str
    description: str
    user_type: UserType
    stories: List[UserStory] = field(default_factory=list)


@dataclass
class StoryMap:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    ç”¨æˆ·æ•…äº‹åœ°å›¾
    activities: List[Activity]
    total_stories: int
    user_types: List[UserType]
    visualization: str  # ASCII å¯è§†åŒ–


@dataclass
class Release:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    å‘å¸ƒè®¡åˆ’
    version: str
    name: str
    stories: List[UserStory]
    total_effort: int  # æ€»å·¥æ—¶
    business_value: int  # æ€»ä¸šåŠ¡ä»·å€¼
    priority_score: float  # ä¼˜å…ˆçº§åˆ†æ•°


@dataclass
class PrioritizedBacklog:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    ä¼˜å…ˆçº§æ’åºçš„å¾…åŠåˆ—è¡¨
    releases: List[Release]
    total_stories: int
    total_effort: int
    prioritization_method: str


class UserStoryMapper:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    ç”¨æˆ·æ•…äº‹åœ°å›¾ç”Ÿæˆå™¨

    def __init__(self):
        """å¾…æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²"""
        self.story_id_counter = 0
        self.activity_id_counter = 0

    def generate_stories_from_requirements(
        """å¾…æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²"""
        self,
        requirements: List[Dict[str, any]]
    ) -> List[UserStory]:
        """ä»éœ€æ±‚ç”Ÿæˆç”¨æˆ·æ•…äº‹

        Args:
            requirements: éœ€æ±‚åˆ—è¡¨,æ¯ä¸ªéœ€æ±‚åŒ…å« title, description, priority ç­‰å­—æ®µ

        Returns:
            ç”¨æˆ·æ•…äº‹åˆ—è¡¨
        """
        stories = []

        for req in requirements:
            self.story_id_counter += 1
            story_id = f"US-{self.story_id_counter:03d}"

            # æ£€æµ‹ç”¨æˆ·ç±»å‹
            user_type = self._detect_user_type(req.get("title", ""), req.get("description", ""))

            # æ˜ å°„ä¼˜å…ˆçº§
            priority = self._map_priority(req.get("priority", "ä¸­"))

            # ä¼°ç®—ä¸šåŠ¡ä»·å€¼
            business_value = self._estimate_business_value(req, priority)

            # ä¼°ç®—å·¥æ—¶
            effort = self._estimate_effort(req)

            # ç”ŸæˆéªŒæ”¶æ ‡å‡†
            acceptance_criteria = self._generate_acceptance_criteria(req)

            story = UserStory(
                id=story_id,
                title=req.get("title", "æœªå‘½åç”¨æˆ·æ•…äº‹"),
                description=self._format_as_user_story(req, user_type),
                user_type=user_type,
                priority=priority,
                business_value=business_value,
                effort_estimate=effort,
                acceptance_criteria=acceptance_criteria,
                tags=req.get("tags", [])
            )

            stories.append(story)

        # æ£€æµ‹ä¾èµ–å…³ç³»
        self._detect_dependencies(stories, requirements)

        return stories

    def _detect_user_type(self, title: str, description: str) -> UserType:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        æ£€æµ‹ç”¨æˆ·ç±»å‹
        text = (title + " " + description).lower()

        if any(keyword in text for keyword in ["ç®¡ç†", "admin", "é…ç½®", "åå°"]):
            return UserType.ADMIN
        elif any(keyword in text for keyword in ["ç³»ç»Ÿ", "è‡ªåŠ¨", "å®šæ—¶", "æ‰¹å¤„ç†"]):
            return UserType.SYSTEM
        elif any(keyword in text for keyword in ["æ¬¡è¦", "è¾…åŠ©", "å¯é€‰"]):
            return UserType.SECONDARY
        else:
            return UserType.PRIMARY

    def _map_priority(self, priority_str: str) -> Priority:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        æ˜ å°„ä¼˜å…ˆçº§
        mapping = {
            "å…³é”®": Priority.CRITICAL,
            "é«˜": Priority.HIGH,
            "ä¸­": Priority.MEDIUM,
            "ä½": Priority.LOW,
            "P0": Priority.CRITICAL,
            "P1": Priority.HIGH,
            "P2": Priority.MEDIUM,
            "P3": Priority.LOW,
        }
        return mapping.get(priority_str, Priority.MEDIUM)

    def _estimate_business_value(self, req: Dict, priority: Priority) -> int:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ä¼°ç®—ä¸šåŠ¡ä»·å€¼(1-100)
        base_value = {
            Priority.CRITICAL: 90,
            Priority.HIGH: 70,
            Priority.MEDIUM: 50,
            Priority.LOW: 30,
        }[priority]

        # æ ¹æ®å…³é”®è¯è°ƒæ•´
        text = (req.get("title", "") + " " + req.get("description", "")).lower()

        if any(keyword in text for keyword in ["æ ¸å¿ƒ", "å…³é”®", "å¿…é¡»", "æ”¶å…¥"]):
            base_value += 10
        if any(keyword in text for keyword in ["å¯é€‰", "æ¬¡è¦", "è¾…åŠ©"]):
            base_value -= 10

        return max(1, min(100, base_value))

    def _estimate_effort(self, req: Dict) -> int:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ä¼°ç®—å·¥æ—¶(å°æ—¶)
        # ç®€åŒ–ä¼°ç®—:åŸºäºæè¿°é•¿åº¦å’Œå¤æ‚åº¦å…³é”®è¯
        description = req.get("description", "")
        base_effort = 8  # é»˜è®¤ 1 å¤©

        if len(description) > 500:
            base_effort += 16
        elif len(description) > 200:
            base_effort += 8

        text = description.lower()
        if any(keyword in text for keyword in ["å¤æ‚", "é›†æˆ", "ç¬¬ä¸‰æ–¹", "ç®—æ³•"]):
            base_effort *= 2
        if any(keyword in text for keyword in ["ç®€å•", "åŸºç¡€", "å¸¸è§„"]):
            base_effort *= 0.5

        return int(base_effort)

    def _generate_acceptance_criteria(self, req: Dict) -> List[str]:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”ŸæˆéªŒæ”¶æ ‡å‡†
        criteria = []

        # åŸºäºæè¿°æå–éªŒæ”¶æ ‡å‡†
        description = req.get("description", "")

        # ç®€åŒ–å®ç°:åŸºäºå…³é”®è¯æå–
        if "å“åº”æ—¶é—´" in description or "æ€§èƒ½" in description:
            criteria.append("ç³»ç»Ÿå“åº”æ—¶é—´æ»¡è¶³æ€§èƒ½è¦æ±‚")

        if "å‡†ç¡®" in description or "æ­£ç¡®" in description:
            criteria.append("åŠŸèƒ½æ­£ç¡®æ€§é€šè¿‡æµ‹è¯•éªŒè¯")

        if "ç”¨æˆ·" in description:
            criteria.append("ç”¨æˆ·ä½“éªŒç¬¦åˆè®¾è®¡è§„èŒƒ")

        # é»˜è®¤æ ‡å‡†
        if not criteria:
            criteria.append(f"å®ç° {req.get('title', 'éœ€æ±‚')} çš„æ ¸å¿ƒåŠŸèƒ½")
            criteria.append("é€šè¿‡æ‰€æœ‰ç›¸å…³æµ‹è¯•ç”¨ä¾‹")

        return criteria

    def _format_as_user_story(self, req: Dict, user_type: UserType) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        æ ¼å¼åŒ–ä¸ºç”¨æˆ·æ•…äº‹æ ¼å¼
        role_map = {
            UserType.PRIMARY: "æ™®é€šç”¨æˆ·",
            UserType.SECONDARY: "æ¬¡è¦ç”¨æˆ·",
            UserType.ADMIN: "ç®¡ç†å‘˜",
            UserType.SYSTEM: "ç³»ç»Ÿ",
        }

        role = role_map[user_type]
        title = req.get("title", "")

        return f"ä½œä¸º{role},æˆ‘æƒ³è¦{title},ä»¥ä¾¿äºæå‡ä¸šåŠ¡ä»·å€¼"

    def _detect_dependencies(self, stories: List[UserStory], requirements: List[Dict]):
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        æ£€æµ‹æ•…äº‹é—´çš„ä¾èµ–å…³ç³»
        # ç®€åŒ–å®ç°:åŸºäºå…³é”®è¯åŒ¹é…
        for i, story in enumerate(stories):
            for j, other_story in enumerate(stories):
                if i != j:
                    # å¦‚æœä¸€ä¸ªæ•…äº‹çš„æ ‡é¢˜å‡ºç°åœ¨å¦ä¸€ä¸ªæ•…äº‹çš„æè¿°ä¸­,å¯èƒ½å­˜åœ¨ä¾èµ–
                    if other_story.title in story.description:
                        if other_story.id not in story.dependencies:
                            story.dependencies.append(other_story.id)

    def generate_story_map(self, user_stories: List[UserStory]) -> StoryMap:
        """ç”Ÿæˆç”¨æˆ·æ•…äº‹åœ°å›¾

        Args:
            user_stories: ç”¨æˆ·æ•…äº‹åˆ—è¡¨

        Returns:
            ç”¨æˆ·æ•…äº‹åœ°å›¾
        """
        # æŒ‰ç”¨æˆ·ç±»å‹åˆ†ç»„
        stories_by_user_type = {}
        for story in user_stories:
            if story.user_type not in stories_by_user_type:
                stories_by_user_type[story.user_type] = []
            stories_by_user_type[story.user_type].append(story)

        # ä¸ºæ¯ä¸ªç”¨æˆ·ç±»å‹åˆ›å»ºæ´»åŠ¨
        activities = []

        for user_type, stories in stories_by_user_type.items():
            # å°†æ•…äº‹æŒ‰ä¼˜å…ˆçº§å’Œä¸šåŠ¡ä»·å€¼åˆ†ç»„ä¸ºæ´»åŠ¨
            activity_groups = self._group_stories_into_activities(stories)

            for group_name, group_stories in activity_groups.items():
                self.activity_id_counter += 1
                activity = Activity(
                    id=f"ACT-{self.activity_id_counter:02d}",
                    name=group_name,
                    description=f"{user_type.value}çš„{group_name}ç›¸å…³æ´»åŠ¨",
                    user_type=user_type,
                    stories=group_stories
                )
                activities.append(activity)

        # ç”Ÿæˆå¯è§†åŒ–
        visualization = self._generate_visualization(activities)

        return StoryMap(
            activities=activities,
            total_stories=len(user_stories),
            user_types=list(stories_by_user_type.keys()),
            visualization=visualization
        )

    def _group_stories_into_activities(self, stories: List[UserStory]) -> Dict[str, List[UserStory]]:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        å°†æ•…äº‹åˆ†ç»„ä¸ºæ´»åŠ¨
        # ç®€åŒ–å®ç°:åŸºäºæ ‡é¢˜ä¸­çš„å…³é”®è¯åˆ†ç»„
        activities = {}

        for story in stories:
            # æå–æ´»åŠ¨åç§°
            activity_name = self._extract_activity_name(story.title)

            if activity_name not in activities:
                activities[activity_name] = []

            activities[activity_name].append(story)

        return activities

    def _extract_activity_name(self, title: str) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ä»æ ‡é¢˜æå–æ´»åŠ¨åç§°
        # ç®€åŒ–å®ç°:æå–å…³é”®åŠ¨è¯
        keywords = {
            "ç”¨æˆ·": "ç”¨æˆ·ç®¡ç†",
            "è®¢å•": "è®¢å•å¤„ç†",
            "å•†å“": "å•†å“ç®¡ç†",
            "æ”¯ä»˜": "æ”¯ä»˜ç»“ç®—",
            "ç™»å½•": "èº«ä»½è®¤è¯",
            "æ³¨å†Œ": "ç”¨æˆ·æ³¨å†Œ",
            "æœç´¢": "æœç´¢åŠŸèƒ½",
            "æ¨è": "æ¨èç³»ç»Ÿ",
            "åˆ†æ": "æ•°æ®åˆ†æ",
            "æŠ¥è¡¨": "æŠ¥è¡¨ç”Ÿæˆ",
        }

        for keyword, activity in keywords.items():
            if keyword in title:
                return activity

        return "æ ¸å¿ƒåŠŸèƒ½"

    def _generate_visualization(self, activities: List[Activity]) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆ ASCII å¯è§†åŒ–
        lines = []
        lines.append("=" * 80)
        lines.append("ç”¨æˆ·æ•…äº‹åœ°å›¾")
        lines.append("=" * 80)

        for activity in activities:
            lines.append(f"\n[{activity.id}] {activity.name} ({activity.user_type.value})")
            lines.append("-" * 80)

            for story in activity.stories:
                priority_icon = {
                    Priority.CRITICAL: "ğŸ”´",
                    Priority.HIGH: "ğŸŸ ",
                    Priority.MEDIUM: "ğŸŸ¡",
                    Priority.LOW: "ğŸŸ¢",
                }[story.priority]

                lines.append(f"  {priority_icon} {story.id}: {story.title}")
                lines.append(f"     ä»·å€¼: {story.business_value}/100 | å·¥æ—¶: {story.effort_estimate}h | ä¼˜å…ˆçº§: {story.priority.value}")

                if story.dependencies:
                    lines.append(f"     ä¾èµ–: {', '.join(story.dependencies)}")

        lines.append("\n" + "=" * 80)

        return "\n".join(lines)

    def prioritize_stories(self, story_map: StoryMap, release_count: int = 3) -> PrioritizedBacklog:
        """åŸºäºåœ°å›¾çš„ä¼˜å…ˆçº§æ’åºå’Œå‘å¸ƒè§„åˆ’

        Args:
            story_map: ç”¨æˆ·æ•…äº‹åœ°å›¾
            release_count: å‘å¸ƒç‰ˆæœ¬æ•°é‡

        Returns:
            ä¼˜å…ˆçº§æ’åºçš„å¾…åŠåˆ—è¡¨
        """
        # æ”¶é›†æ‰€æœ‰æ•…äº‹
        all_stories = []
        for activity in story_map.activities:
            all_stories.extend(activity.stories)

        # è®¡ç®—ä¼˜å…ˆçº§åˆ†æ•°:ç»¼åˆè€ƒè™‘ä¸šåŠ¡ä»·å€¼,ä¼˜å…ˆçº§,å·¥æ—¶
        scored_stories = []
        for story in all_stories:
            priority_weight = {
                Priority.CRITICAL: 4,
                Priority.HIGH: 3,
                Priority.MEDIUM: 2,
                Priority.LOW: 1,
            }[story.priority]

            # ä¼˜å…ˆçº§åˆ†æ•° = (ä¸šåŠ¡ä»·å€¼ * ä¼˜å…ˆçº§æƒé‡) / å·¥æ—¶
            # ç›®æ ‡:é«˜ä»·å€¼,é«˜ä¼˜å…ˆçº§,ä½å·¥æ—¶çš„æ•…äº‹åˆ†æ•°æœ€é«˜
            score = (story.business_value * priority_weight) / max(1, story.effort_estimate / 8)

            scored_stories.append((story, score))

        # æŒ‰åˆ†æ•°æ’åº(é™åº)
        scored_stories.sort(key=lambda x: x[1], reverse=True)

        # åˆ†é…åˆ°å‘å¸ƒç‰ˆæœ¬
        releases = self._plan_releases(scored_stories, release_count)

        total_effort = sum(release.total_effort for release in releases)

        return PrioritizedBacklog(
            releases=releases,
            total_stories=len(all_stories),
            total_effort=total_effort,
            prioritization_method="ä»·å€¼é©±åŠ¨ä¼˜å…ˆçº§æ’åº (ä¸šåŠ¡ä»·å€¼ Ã— ä¼˜å…ˆçº§æƒé‡ / å·¥æ—¶)"
        )

    def _plan_releases(self, scored_stories: List[Tuple[UserStory, float]], release_count: int) -> List[Release]:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è§„åˆ’å‘å¸ƒç‰ˆæœ¬
        releases = []

        # è€ƒè™‘ä¾èµ–å…³ç³»çš„æ‹“æ‰‘æ’åº
        sorted_stories = self._topological_sort(scored_stories)

        # åˆ†é…æ•…äº‹åˆ°ç‰ˆæœ¬(ç®€åŒ–å®ç°:å‡åˆ†)
        stories_per_release = len(sorted_stories) // release_count

        for i in range(release_count):
            version = f"v{i+1}.0"
            start_idx = i * stories_per_release

            if i == release_count - 1:
                # æœ€åä¸€ä¸ªç‰ˆæœ¬åŒ…å«æ‰€æœ‰å‰©ä½™æ•…äº‹
                release_stories = [s for s, _ in sorted_stories[start_idx:]]
            else:
                release_stories = [s for s, _ in sorted_stories[start_idx:start_idx + stories_per_release]]

            total_effort = sum(s.effort_estimate for s in release_stories)
            total_value = sum(s.business_value for s in release_stories)
            avg_score = sum(score for _, score in sorted_stories[start_idx:start_idx + len(release_stories)]) / max(1, len(release_stories))

            release = Release(
                version=version,
                name=f"å‘å¸ƒ {version}",
                stories=release_stories,
                total_effort=total_effort,
                business_value=total_value,
                priority_score=avg_score
            )

            releases.append(release)

        return releases

    def _topological_sort(self, scored_stories: List[Tuple[UserStory, float]]) -> List[Tuple[UserStory, float]]:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        æ‹“æ‰‘æ’åº(è€ƒè™‘ä¾èµ–å…³ç³»)
        # ç®€åŒ–å®ç°:ä¿æŒåŸæœ‰åˆ†æ•°æ’åº,ä½†ç¡®ä¿ä¾èµ–çš„æ•…äº‹æ’åœ¨å‰é¢
        stories = [s for s, _ in scored_stories]
        scores = {s.id: score for s, score in scored_stories}

        # æ„å»ºä¾èµ–å›¾
        story_map = {s.id: s for s in stories}

        # ä½¿ç”¨ Kahn ç®—æ³•è¿›è¡Œæ‹“æ‰‘æ’åº
        in_degree = {s.id: 0 for s in stories}

        for story in stories:
            for dep_id in story.dependencies:
                if dep_id in in_degree:
                    in_degree[story.id] += 1

        # é˜Ÿåˆ—:æ‰€æœ‰å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹
        queue = [s for s in stories if in_degree[s.id] == 0]
        result = []

        while queue:
            # æŒ‰åˆ†æ•°æ’åº,ä¼˜å…ˆå¤„ç†é«˜åˆ†æ•…äº‹
            queue.sort(key=lambda s: scores[s.id], reverse=True)
            current = queue.pop(0)
            result.append((current, scores[current.id]))

            # æ›´æ–°ä¾èµ–æ­¤æ•…äº‹çš„å…¶ä»–æ•…äº‹
            for story in stories:
                if current.id in story.dependencies:
                    in_degree[story.id] -= 1
                    if in_degree[story.id] == 0 and story not in [s for s, _ in result]:
                        queue.append(story)

        # å¦‚æœæœ‰å¾ªç¯ä¾èµ–,æ·»åŠ å‰©ä½™æ•…äº‹
        for story in stories:
            if story not in [s for s, _ in result]:
                result.append((story, scores[story.id]))

        return result


# ============================================================================
# æµ‹è¯•ä»£ç 
# ============================================================================

if __name__ == "__main__":
    print("=" * 80)
    print("ç”¨æˆ·æ•…äº‹åœ°å›¾æµ‹è¯•")
    print("=" * 80)

    # æµ‹è¯•æ•°æ®:æ¨¡æ‹Ÿéœ€æ±‚
    requirements = [
        {
            "title": "ç”¨æˆ·æ³¨å†ŒåŠŸèƒ½",
            "description": "ç”¨æˆ·å¯ä»¥é€šè¿‡é‚®ç®±æ³¨å†Œè´¦å·,éœ€è¦é‚®ç®±éªŒè¯.å“åº”æ—¶é—´åº”å°äº 2 ç§’.",
            "priority": "é«˜"
        },
        {
            "title": "ç”¨æˆ·ç™»å½•åŠŸèƒ½",
            "description": "ç”¨æˆ·å¯ä»¥é€šè¿‡é‚®ç®±å’Œå¯†ç ç™»å½•,æ”¯æŒè®°ä½ç™»å½•çŠ¶æ€.éœ€è¦ç”¨æˆ·æ³¨å†ŒåŠŸèƒ½.",
            "priority": "å…³é”®"
        },
        {
            "title": "å•†å“æœç´¢åŠŸèƒ½",
            "description": "ç”¨æˆ·å¯ä»¥æœç´¢å•†å“,æ”¯æŒå…³é”®è¯,åˆ†ç±»,ä»·æ ¼åŒºé—´ç­›é€‰.éœ€è¦å¤æ‚çš„ç®—æ³•.",
            "priority": "é«˜"
        },
        {
            "title": "è®¢å•ç®¡ç†åŠŸèƒ½",
            "description": "ç®¡ç†å‘˜å¯ä»¥æŸ¥çœ‹å’Œç®¡ç†æ‰€æœ‰è®¢å•,åŒ…æ‹¬è®¢å•çŠ¶æ€æ›´æ–°,é€€æ¬¾å¤„ç†ç­‰.",
            "priority": "ä¸­"
        },
        {
            "title": "æ¨èç³»ç»Ÿ",
            "description": "ç³»ç»Ÿè‡ªåŠ¨æ ¹æ®ç”¨æˆ·è¡Œä¸ºæ¨èå•†å“.éœ€è¦é›†æˆç¬¬ä¸‰æ–¹ AI æœåŠ¡.",
            "priority": "ä¸­"
        },
    ]

    mapper = UserStoryMapper()

    # æ­¥éª¤ 1:ç”Ÿæˆç”¨æˆ·æ•…äº‹
    print("\næ­¥éª¤ 1:ä»éœ€æ±‚ç”Ÿæˆç”¨æˆ·æ•…äº‹")
    print("-" * 80)
    user_stories = mapper.generate_stories_from_requirements(requirements)

    for story in user_stories:
        print(f"\n{story.id}: {story.title}")
        print(f"  æè¿°: {story.description}")
        print(f"  ç”¨æˆ·ç±»å‹: {story.user_type.value}")
        print(f"  ä¼˜å…ˆçº§: {story.priority.value}")
        print(f"  ä¸šåŠ¡ä»·å€¼: {story.business_value}/100")
        print(f"  å·¥æ—¶ä¼°ç®—: {story.effort_estimate}h")
        if story.dependencies:
            print(f"  ä¾èµ–: {', '.join(story.dependencies)}")
        print(f"  éªŒæ”¶æ ‡å‡†:")
        for criterion in story.acceptance_criteria:
            print(f"    - {criterion}")

    # æ­¥éª¤ 2:ç”Ÿæˆç”¨æˆ·æ•…äº‹åœ°å›¾
    print("\n\næ­¥éª¤ 2:ç”Ÿæˆç”¨æˆ·æ•…äº‹åœ°å›¾")
    print("-" * 80)
    story_map = mapper.generate_story_map(user_stories)

    print(story_map.visualization)

    print(f"\næ€»æ•…äº‹æ•°: {story_map.total_stories}")
    print(f"ç”¨æˆ·ç±»å‹æ•°: {len(story_map.user_types)}")
    print(f"æ´»åŠ¨æ•°: {len(story_map.activities)}")

    # æ­¥éª¤ 3:ä¼˜å…ˆçº§æ’åºå’Œå‘å¸ƒè§„åˆ’
    print("\n\næ­¥éª¤ 3:ä¼˜å…ˆçº§æ’åºå’Œå‘å¸ƒè§„åˆ’")
    print("-" * 80)
    backlog = mapper.prioritize_stories(story_map, release_count=2)

    print(f"\næ’åºæ–¹æ³•: {backlog.prioritization_method}")
    print(f"æ€»æ•…äº‹æ•°: {backlog.total_stories}")
    print(f"æ€»å·¥æ—¶: {backlog.total_effort}h ({backlog.total_effort / 8:.1f} å¤©)")

    for release in backlog.releases:
        print(f"\n{release.version}: {release.name}")
        print(f"  æ•…äº‹æ•°: {len(release.stories)}")
        print(f"  æ€»å·¥æ—¶: {release.total_effort}h ({release.total_effort / 8:.1f} å¤©)")
        print(f"  ä¸šåŠ¡ä»·å€¼: {release.business_value}")
        print(f"  ä¼˜å…ˆçº§åˆ†æ•°: {release.priority_score:.2f}")
        print(f"  åŒ…å«æ•…äº‹:")

        for story in release.stories:
            print(f"    - {story.id}: {story.title} (ä¼˜å…ˆçº§: {story.priority.value})")

    print("\n" + "=" * 80)
    print("æµ‹è¯•å®Œæˆ")
    print("=" * 80)


# Error handling example
try:
    pass
except Exception:
    pass
