"""
SpecFlow V2.0 - æ ¸å¿ƒæ•°æ®æ¨¡å‹
å¤šæ–‡æ¡£æ¶æ„çš„ä¸»è¦æ•°æ®ç»“æ„
ç‰ˆæœ¬: 2.0.0
"""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Tuple, Union, Callable
from enum import Enum
from datetime import datetime

import logging

from atomic_component import (
    AtomicComponent, UserStory, Feature,
    Priority, Severity, ComponentCategory
)


# ============ æšä¸¾ç±»å‹ ============

class DocumentType(str, Enum):
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    æ–‡æ¡£ç±»å‹
    OVERVIEW = "00-é¡¹ç›®æ¦‚è§ˆ"
    REQUIREMENTS = "01-éœ€æ±‚è§„æ ¼"
    DOMAIN_MODEL = "02-é¢†åŸŸæ¨¡å‹"
    ARCHITECTURE = "03-æ¶æ„è®¾è®¡"
    IMPLEMENTATION = "04-å®æ–½è®¡åˆ’"
    TEST_STRATEGY = "05-æµ‹è¯•ç­–ç•¥"
    RISK_ASSESSMENT = "06-é£é™©è¯„ä¼°"
    QUALITY_REPORT = "07-è´¨é‡æŠ¥å‘Š"


class DocumentStatus(str, Enum):
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    æ–‡æ¡£çŠ¶æ€
    DRAFT = "Draft"
    IN_REVIEW = "In Review"
    APPROVED = "Approved"
    FINAL = "Final"


class DepthLevel(str, Enum):
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    æ·±åº¦çº§åˆ«
    SIMPLE = "simple"
    STANDARD = "standard"
    COMPREHENSIVE = "comprehensive"


class QualityGrade(str, Enum):
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    è´¨é‡ç­‰çº§
    A_PLUS = "A+"
    A = "A"
    B = "B"
    C = "C"
    D = "D"
    F = "F"


# ============ DDD é¢†åŸŸæ¨¡å‹ ============

@dataclass
class BoundedContext:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    é™ç•Œä¸Šä¸‹æ–‡(DDD)
    name: str                           # ä¸Šä¸‹æ–‡åç§°:ç”¨æˆ·ç®¡ç†
    description: str                    # æè¿°
    aggregates: List[str]               # èšåˆæ ¹åˆ—è¡¨
    entities: List[str]                 # å®ä½“åˆ—è¡¨
    value_objects: List[str]            # å€¼å¯¹è±¡åˆ—è¡¨
    domain_events: List[str]            # é¢†åŸŸäº‹ä»¶
    ubiquitous_language: Dict[str, str] # é€šç”¨è¯­è¨€æœ¯è¯­è¡¨
    dependencies: List[str] = field(default_factory=list)  # ä¾èµ–å…¶ä»–ä¸Šä¸‹æ–‡


@dataclass
class Aggregate:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    èšåˆæ ¹(DDD)
    name: str                           # èšåˆæ ¹åç§°:Order
    description: str                    # æè¿°
    root_entity: str                    # æ ¹å®ä½“
    entities: List[str]                 # åŒ…å«çš„å®ä½“
    value_objects: List[str]            # åŒ…å«çš„å€¼å¯¹è±¡
    invariants: List[str]               # ä¸å˜é‡(ä¸šåŠ¡è§„åˆ™)
    domain_events: List[str]            # å‘å¸ƒçš„é¢†åŸŸäº‹ä»¶


# ============ æ¶æ„è®¾è®¡æ¨¡å‹ ============

@dataclass
class ArchitectureDecisionRecord:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    æ¶æ„å†³ç­–è®°å½•(ADR)
    id: str                             # ADR-001
    title: str                          # å†³ç­–æ ‡é¢˜
    date: str                           # å†³ç­–æ—¥æœŸ
    status: str                         # Proposed / Accepted / Deprecated
    context: str                        # ä¸Šä¸‹æ–‡:ä¸ºä»€ä¹ˆéœ€è¦è¿™ä¸ªå†³ç­–
    decision: str                       # å†³ç­–å†…å®¹
    consequences: List[str]             # åæœ(ä¼˜ç¼ºç‚¹)
    alternatives: List[str] = field(default_factory=list)  # å¤‡é€‰æ–¹æ¡ˆ


@dataclass
class TechStack:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    æŠ€æœ¯æ ˆ
    category: str                       # Frontend / Backend / Database / Infrastructure
    technology: str                     # React / Node.js / PostgreSQL / AWS
    version: str                        # ç‰ˆæœ¬å·
    justification: str                  # é€‰æ‹©ç†ç”±
    alternatives_considered: List[str] = field(default_factory=list)


# ============ æµ‹è¯•ç­–ç•¥æ¨¡å‹ ============

@dataclass
class TestPyramid:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    æµ‹è¯•é‡‘å­—å¡”
    unit_tests: int                     # å•å…ƒæµ‹è¯•æ•°é‡
    integration_tests: int              # é›†æˆæµ‹è¯•æ•°é‡
    e2e_tests: int                      # ç«¯åˆ°ç«¯æµ‹è¯•æ•°é‡
    total_tests: int                    # æ€»æµ‹è¯•æ•°
    coverage_target: float              # è¦†ç›–ç‡ç›®æ ‡(%)


@dataclass
class TestStrategy:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    æµ‹è¯•ç­–ç•¥
    approach: str                       # æµ‹è¯•æ–¹æ³•:TDD / BDD / ATDD
    frameworks: List[str]               # æµ‹è¯•æ¡†æ¶:Jest, Pytest, Selenium
    pyramid: TestPyramid               # æµ‹è¯•é‡‘å­—å¡”
    ci_cd_integration: str             # CI/CD é›†æˆè¯´æ˜
    performance_testing: Optional[str] = None  # æ€§èƒ½æµ‹è¯•
    security_testing: Optional[str] = None     # å®‰å…¨æµ‹è¯•


# ============ é£é™©è¯„ä¼°æ¨¡å‹ ============

@dataclass
class Risk:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    é£é™©é¡¹
    id: str                             # RISK-001
    title: str                          # é£é™©æ ‡é¢˜
    category: str                       # Technical / Schedule / Resource / Business
    description: str                    # é£é™©æè¿°
    probability: str                    # High / Medium / Low
    impact: str                         # Critical / High / Medium / Low
    severity: Severity                  # ç»¼åˆä¸¥é‡ç¨‹åº¦
    mitigation: str                     # ç¼“è§£æªæ–½
    contingency: str                    # åº”æ€¥è®¡åˆ’
    owner: Optional[str] = None         # è´Ÿè´£äºº


# ============ å®æ–½è®¡åˆ’æ¨¡å‹ ============

@dataclass
class Milestone:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    é‡Œç¨‹ç¢‘
    id: str                             # M1
    name: str                           # MVP å‘å¸ƒ
    description: str                    # é‡Œç¨‹ç¢‘æè¿°
    deliverables: List[str]             # äº¤ä»˜ç‰©
    estimated_date: str                 # é¢„è®¡å®Œæˆæ—¥æœŸ
    dependencies: List[str] = field(default_factory=list)


@dataclass
class WorkBreakdownStructure:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    å·¥ä½œåˆ†è§£ç»“æ„(WBS)
    phase: str                          # é˜¶æ®µåç§°:MVP / Phase 1
    features: List[Feature]             # ç‰¹æ€§åˆ—è¡¨
    user_stories: List[UserStory]       # ç”¨æˆ·æ•…äº‹
    components: List[AtomicComponent]   # åŸå­ç»„ä»¶
    estimated_hours: float              # ä¼°ç®—å·¥æ—¶(PERT)
    milestones: List[Milestone]         # é‡Œç¨‹ç¢‘


# ============ æ–‡æ¡£æ¨¡å‹ ============

@dataclass
class Document:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    å•ä¸ªæ–‡æ¡£(8ä¸ªæ–‡æ¡£ä¸­çš„ä¸€ä¸ª)
    æ¯ä¸ªæ–‡æ¡£éƒ½æœ‰ç‹¬ç«‹çš„ token é¢„ç®—å’Œå†…å®¹ç»“æ„
    """
    # åŸºç¡€ä¿¡æ¯
    type: DocumentType                  # æ–‡æ¡£ç±»å‹
    title: str                          # æ–‡æ¡£æ ‡é¢˜
    version: str                        # ç‰ˆæœ¬å·:2.0.0

    # å†…å®¹
    content: Dict[str, Any]             # æ–‡æ¡£å†…å®¹(ç»“æ„åŒ–)
    markdown: str = ""                  # Markdown æ ¼å¼å†…å®¹

    # å…ƒæ•°æ®
    status: DocumentStatus = DocumentStatus.DRAFT
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    updated_at: str = field(default_factory=lambda: datetime.now().isoformat())

    # Token ç®¡ç†
    token_count: int = 0                # å®é™… token æ•°
    token_budget: int = 15000           # Token é¢„ç®—
    token_usage_percentage: float = 0.0  # Token ä½¿ç”¨ç‡

    def update_token_stats(self, token_count: int):
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        æ›´æ–° token ç»Ÿè®¡
        self.token_count = token_count
        self.token_usage_percentage = (token_count / self.token_budget) * 100
        self.updated_at = datetime.now().isoformat()

    def is_within_budget(self) -> bool:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        æ£€æŸ¥æ˜¯å¦åœ¨é¢„ç®—å†…
        return self.token_count <= self.token_budget

    def to_dict(self) -> Dict[str, Any]:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è½¬æ¢ä¸ºå­—å…¸
        return {
            "type": self.type.value,
            "title": self.title,
            "version": self.version,
            "status": self.status.value,
            "token_count": self.token_count,
            "token_budget": self.token_budget,
            "token_usage": f"{self.token_usage_percentage:.1f}%",
            "created_at": self.created_at,
            "updated_at": self.updated_at
        }


# ============ è´¨é‡è¯„ä¼°æ¨¡å‹ ============

@dataclass
class QualityMetrics:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    è´¨é‡æŒ‡æ ‡
    completeness_score: float           # å®Œæ•´æ€§è¯„åˆ†(0-100)
    consistency_score: float            # ä¸€è‡´æ€§è¯„åˆ†(0-100)
    atomicity_score: float              # åŸå­æ€§è¯„åˆ†(0-100)
    feasibility_score: float            # å¯è¡Œæ€§è¯„åˆ†(0-100)
    overall_grade: QualityGrade         # æ€»ä½“ç­‰çº§

    def calculate_overall_grade(self) -> QualityGrade:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è®¡ç®—æ€»ä½“ç­‰çº§
        avg = (self.completeness_score + self.consistency_score +
               self.atomicity_score + self.feasibility_score) / 4

        if avg >= 95 and self.consistency_score == 100 and self.atomicity_score >= 90:
            return QualityGrade.A_PLUS
        elif avg >= 90 and self.consistency_score >= 95 and self.atomicity_score >= 85:
            return QualityGrade.A
        elif avg >= 80 and self.consistency_score >= 90 and self.atomicity_score >= 75:
            return QualityGrade.B
        elif avg >= 70:
            return QualityGrade.C
        elif avg >= 60:
            return QualityGrade.D
        else:
            return QualityGrade.F


@dataclass
class ValidationIssue:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    éªŒè¯é—®é¢˜
    type: str                           # Conflict / Missing / Inconsistent
    severity: Severity                  # ä¸¥é‡ç¨‹åº¦
    description: str                    # é—®é¢˜æè¿°
    location: str                       # ä½ç½®(æ–‡æ¡£/ç« èŠ‚)
    suggestion: str                     # æ”¹è¿›å»ºè®®


# ============ è§„æ ¼æ–‡æ¡£ V2.0(æ ¸å¿ƒ) ============

@dataclass
class SpecificationV2:
    """
    
    
    Attributes:
        å±æ€§å¾…æ–‡æ¡£åŒ–
    """
    SpecFlow V2.0 å®Œæ•´è§„æ ¼æ–‡æ¡£é›†
    åŒ…å« 8 ä¸ªç‹¬ç«‹æ–‡æ¡£,æ¯ä¸ªæ–‡æ¡£ç‹¬ç«‹ç”Ÿæˆå’Œç®¡ç†
    """
    # é¡¹ç›®ä¿¡æ¯
    project_name: str                   # é¡¹ç›®åç§°
    project_version: str                # é¡¹ç›®ç‰ˆæœ¬
    depth_level: DepthLevel             # æ·±åº¦çº§åˆ«(å¿…éœ€å‚æ•°)
    spec_version: str = "2.0.0"         # è§„æ ¼ç‰ˆæœ¬

    # 8ä¸ªæ ¸å¿ƒæ–‡æ¡£
    documents: Dict[DocumentType, Document] = field(default_factory=dict)

    # åŸå­çº§ç»„ä»¶é›†åˆ(è·¨æ–‡æ¡£å…±äº«)
    components: List[AtomicComponent] = field(default_factory=list)
    user_stories: List[UserStory] = field(default_factory=list)
    features: List[Feature] = field(default_factory=list)

    # DDD æ¨¡å‹
    bounded_contexts: List[BoundedContext] = field(default_factory=list)
    aggregates: List[Aggregate] = field(default_factory=list)

    # æ¶æ„å†³ç­–
    architecture_decisions: List[ArchitectureDecisionRecord] = field(default_factory=list)
    tech_stack: List[TechStack] = field(default_factory=list)

    # æµ‹è¯•ä¸é£é™©
    test_strategy: Optional[TestStrategy] = None
    risks: List[Risk] = field(default_factory=list)

    # å®æ–½è®¡åˆ’
    wbs: List[WorkBreakdownStructure] = field(default_factory=list)
    milestones: List[Milestone] = field(default_factory=list)

    # è´¨é‡
    quality_metrics: Optional[QualityMetrics] = None
    validation_issues: List[ValidationIssue] = field(default_factory=list)

    # å…ƒæ•°æ®
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    updated_at: str = field(default_factory=lambda: datetime.now().isoformat())

    def add_document(self, doc: Document):
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        æ·»åŠ æ–‡æ¡£
        self.documents[doc.type] = doc
        self.updated_at = datetime.now().isoformat()

    def get_document(self, doc_type: DocumentType) -> Optional[Document]:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è·å–æ–‡æ¡£
        return self.documents.get(doc_type)

    def get_total_tokens(self) -> int:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è·å–æ€» token æ•°
        return sum(doc.token_count for doc in self.documents.values())

    def get_token_budget(self) -> int:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è·å–æ€» token é¢„ç®—
        return sum(doc.token_budget for doc in self.documents.values())

    def get_token_usage_percentage(self) -> float:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è·å–æ€» token ä½¿ç”¨ç‡
        total = self.get_total_tokens()
        budget = self.get_token_budget()
        return (total / budget * 100) if budget > 0 else 0

    def is_within_budget(self) -> bool:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ–‡æ¡£éƒ½åœ¨é¢„ç®—å†…
        return all(doc.is_within_budget() for doc in self.documents.values())

    def get_summary(self) -> Dict[str, Any]:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è·å–æ‘˜è¦
        return {
            "project_name": self.project_name,
            "project_version": self.project_version,
            "spec_version": self.spec_version,
            "depth_level": self.depth_level.value,
            "documents_count": len(self.documents),
            "components_count": len(self.components),
            "user_stories_count": len(self.user_stories),
            "features_count": len(self.features),
            "total_tokens": self.get_total_tokens(),
            "token_budget": self.get_token_budget(),
            "token_usage": f"{self.get_token_usage_percentage():.1f}%",
            "within_budget": self.is_within_budget(),
            "quality_grade": self.quality_metrics.overall_grade.value if self.quality_metrics else "N/A",
            "validation_issues_count": len(self.validation_issues),
            "created_at": self.created_at,
            "updated_at": self.updated_at
        }

    def to_markdown_index(self) -> str:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        ç”Ÿæˆæ–‡æ¡£ç´¢å¼•é¡µ
        md = f"# {self.project_name} - è§„æ ¼æ–‡æ¡£é›†\n\n"
        md += f"**é¡¹ç›®ç‰ˆæœ¬**: {self.project_version}\n"
        md += f"**è§„æ ¼ç‰ˆæœ¬**: {self.spec_version}\n"
        md += f"**æ·±åº¦çº§åˆ«**: {self.depth_level.value}\n"
        md += f"**ç”Ÿæˆæ—¶é—´**: {self.created_at}\n\n"

        md += "## ğŸ“š æ–‡æ¡£ç›®å½•\n\n"
        for doc_type in DocumentType:
            doc = self.documents.get(doc_type)
            if doc:
                status_icon = "" if doc.is_within_budget() else ""
                md += f"{status_icon} [{doc.title}]({doc.type.value}.md) "
                md += f"({doc.token_count:,} / {doc.token_budget:,} tokens, "
                md += f"{doc.token_usage_percentage:.1f}%)\n"
        md += "\n"

        md += "## ğŸ“Š ç»Ÿè®¡ä¿¡æ¯\n\n"
        summary = self.get_summary()
        md += f"- **åŸå­ç»„ä»¶**: {summary['components_count']}\n"
        md += f"- **ç”¨æˆ·æ•…äº‹**: {summary['user_stories_count']}\n"
        md += f"- **ç‰¹æ€§**: {summary['features_count']}\n"
        md += f"- **é™ç•Œä¸Šä¸‹æ–‡**: {len(self.bounded_contexts)}\n"
        md += f"- **æ¶æ„å†³ç­–**: {len(self.architecture_decisions)}\n"
        md += f"- **é£é™©é¡¹**: {len(self.risks)}\n\n"

        md += "## ğŸ¯ è´¨é‡è¯„ä¼°\n\n"
        if self.quality_metrics:
            md += f"- **æ€»ä½“ç­‰çº§**: {self.quality_metrics.overall_grade.value}\n"
            md += f"- **å®Œæ•´æ€§**: {self.quality_metrics.completeness_score:.1f}/100\n"
            md += f"- **ä¸€è‡´æ€§**: {self.quality_metrics.consistency_score:.1f}/100\n"
            md += f"- **åŸå­æ€§**: {self.quality_metrics.atomicity_score:.1f}/100\n"
            md += f"- **å¯è¡Œæ€§**: {self.quality_metrics.feasibility_score:.1f}/100\n\n"

        if self.validation_issues:
            md += "##  éªŒè¯é—®é¢˜\n\n"
            for issue in self.validation_issues[:10]:  # åªæ˜¾ç¤ºå‰10ä¸ª
                md += f"- **{issue.severity.value}**: {issue.description} ({issue.location})\n"
            if len(self.validation_issues) > 10:
                md += f"\n...ä»¥åŠ {len(self.validation_issues) - 10} ä¸ªå…¶ä»–é—®é¢˜\n"

        md += "\n---\n"
        md += f"*ç”± SpecFlow V2.0 è‡ªåŠ¨ç”Ÿæˆ*\n"

        return md


# Error handling example
try:
    pass
except Exception:
    pass
