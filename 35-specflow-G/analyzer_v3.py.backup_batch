"""
è§„æ ¼æ–‡æ¡£è´¨é‡åˆ†æå™¨(V3.0)

åŸºäºè§„åˆ™å¼•æ“åˆ†æè§„æ ¼æ–‡æ¡£è´¨é‡,è®¡ç®—è´¨é‡æŒ‡æ ‡å’Œç”Ÿæˆæ”¹è¿›å»ºè®®.
"""

from typing import List, Dict, Tuple, Optional, Any, Union, Callable
import logging

from core.models import (
    SpecificationDocument,
    QualityReport,
    QualityMetrics,
    QualityGrade,
    ValidationIssue,
    RequirementItem,
    UserStory,
    DomainCategory,
    ComplexityLevel,
    Priority,
    Severity
)


class SpecificationAnalyzer:
    """
    è§„æ ¼æ–‡æ¡£è´¨é‡åˆ†æå™¨

    èŒè´£:
    1. åˆ†æè§„æ ¼æ–‡æ¡£çš„å®Œæ•´æ€§
    2. æ£€æŸ¥ä¸€è‡´æ€§é—®é¢˜
    3. è¯„ä¼°éœ€æ±‚çš„åŸå­æ€§
    4. è¯„ä¼°å¯æµ‹è¯•æ€§
    5. ç”Ÿæˆè´¨é‡æŠ¥å‘Šå’Œæ”¹è¿›å»ºè®®

    Attributes:
        æš‚æ— å±æ€§
    """

    def __init__(self):
        """
        åˆå§‹åŒ–åˆ†æå™¨
        """
        pass

    def analyze(self, spec: SpecificationDocument) -> QualityReport:
        """
        åˆ†æè§„æ ¼æ–‡æ¡£è´¨é‡

        Args:
            spec: å¾…åˆ†æçš„è§„æ ¼æ–‡æ¡£

        Returns:
            QualityReport: åŒ…å«è´¨é‡æŒ‡æ ‡,éªŒè¯é—®é¢˜å’Œæ”¹è¿›å»ºè®®çš„è´¨é‡æŠ¥å‘Š
        """
        # 1. è®¡ç®—è´¨é‡æŒ‡æ ‡
        metrics = self._calculate_quality_metrics(spec)

        # 2. æ”¶é›†éªŒè¯é—®é¢˜
        validation_issues = self._collect_validation_issues(spec)

        # 3. ç”Ÿæˆæ”¹è¿›å»ºè®®
        recommendations = self._generate_recommendations(spec, metrics, validation_issues)

        # 4. ä¼°ç®—å·¥æ—¶
        estimated_hours = self._estimate_hours(spec)

        # 5. åˆ›å»ºè´¨é‡æŠ¥å‘Š
        quality_report = QualityReport(
            domain=spec.domain if hasattr(spec, 'domain') else DomainCategory.OTHER,
            complexity=spec.complexity if hasattr(spec, 'complexity') else ComplexityLevel.MEDIUM,
            estimated_hours=estimated_hours,
            metrics=metrics,
            validation_issues=validation_issues,
            recommendations=recommendations
        )

        return quality_report

    def _calculate_quality_metrics(self, spec: SpecificationDocument) -> QualityMetrics:
        """
        è®¡ç®—è´¨é‡æŒ‡æ ‡

        è¯„åˆ†è§„åˆ™:
        - å®Œæ•´æ€§:æ£€æŸ¥å¿…è¦æ–‡æ¡£,éœ€æ±‚,ç”¨æˆ·æ•…äº‹,éªŒæ”¶æ ‡å‡†æ˜¯å¦é½å…¨
        - ä¸€è‡´æ€§:æ£€æŸ¥æœ¯è¯­,ä¼˜å…ˆçº§,ä¾èµ–å…³ç³»æ˜¯å¦ä¸€è‡´
        - åŸå­æ€§:è¯„ä¼°éœ€æ±‚æ˜¯å¦è¶³å¤Ÿç»†åŒ–å’Œç‹¬ç«‹
        - å¯æµ‹è¯•æ€§:è¯„ä¼°éªŒæ”¶æ ‡å‡†å’Œæµ‹è¯•ç”¨ä¾‹çš„è´¨é‡

        Args:
            spec: è§„æ ¼æ–‡æ¡£

        Returns:
            QualityMetrics: è´¨é‡æŒ‡æ ‡
        """
        # 1. è®¡ç®—å®Œæ•´æ€§ (0-100)
        completeness = self._calculate_completeness(spec)

        # 2. è®¡ç®—ä¸€è‡´æ€§ (0-100)
        consistency = self._calculate_consistency(spec)

        # 3. è®¡ç®—åŸå­æ€§ (0-100)
        atomicity = self._calculate_atomicity(spec)

        # 4. è®¡ç®—å¯æµ‹è¯•æ€§ (0-100)
        testability = self._calculate_testability(spec)

        # 5. åˆ›å»ºè´¨é‡æŒ‡æ ‡
        metrics = QualityMetrics(
            completeness_score=round(completeness, 2),
            consistency_score=round(consistency, 2),
            atomicity_score=round(atomicity, 2),
            testability_score=round(testability, 2),
            overall_grade=QualityGrade.C  # ä¸´æ—¶å€¼,ç¨åè®¡ç®—
        )

        # 6. è®¡ç®—æ€»ä½“ç­‰çº§
        metrics.overall_grade = metrics.calculate_overall_grade()

        return metrics

    def _calculate_completeness(self, spec: SpecificationDocument) -> float:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è®¡ç®—å®Œæ•´æ€§å¾—åˆ†

        æ£€æŸ¥é¡¹(æ¯é¡¹10åˆ†,æ€»100åˆ†):
        1. æœ‰é¡¹ç›®åç§°å’Œç‰ˆæœ¬
        2. æœ‰éœ€æ±‚åˆ—è¡¨(è‡³å°‘3ä¸ª)
        3. æœ‰ç”¨æˆ·æ•…äº‹(è‡³å°‘5ä¸ª)
        4. ç”¨æˆ·æ•…äº‹æœ‰éªŒæ”¶æ ‡å‡†
        5. æœ‰é¢†åŸŸæ¨¡å‹æ–‡æ¡£
        6. æœ‰æ¶æ„è®¾è®¡æ–‡æ¡£
        7. æœ‰å®æ–½è®¡åˆ’æ–‡æ¡£
        8. æœ‰æµ‹è¯•ç­–ç•¥æ–‡æ¡£
        9. æœ‰é£é™©è¯„ä¼°æ–‡æ¡£
        10. æœ‰è´¨é‡æŠ¥å‘Šæ–‡æ¡£
        """
        score = 0.0

        # 1. é¡¹ç›®åŸºæœ¬ä¿¡æ¯ (10åˆ†)
        if spec.project_name and spec.project_name != "æœªå‘½åé¡¹ç›®":
            score += 10

        # 2. éœ€æ±‚åˆ—è¡¨ (10åˆ†)
        if len(spec.requirements) >= 3:
            score += 10
        elif len(spec.requirements) >= 1:
            score += 5

        # 3. ç”¨æˆ·æ•…äº‹ (10åˆ†)
        if len(spec.user_stories) >= 5:
            score += 10
        elif len(spec.user_stories) >= 3:
            score += 7
        elif len(spec.user_stories) >= 1:
            score += 4

        # 4. éªŒæ”¶æ ‡å‡† (10åˆ†)
        if spec.user_stories:
            stories_with_ac = sum(1 for story in spec.user_stories if story.acceptance_criteria)
            ac_ratio = stories_with_ac / len(spec.user_stories)
            score += ac_ratio * 10

        # 5-10. æ–‡æ¡£å®Œæ•´æ€§ (æ¯ä¸ª10åˆ†,å…±60åˆ†)
        from core.models import DocumentType
        required_docs = [
            DocumentType.DOMAIN_MODEL,
            DocumentType.ARCHITECTURE,
            DocumentType.IMPLEMENTATION,
            DocumentType.TEST_STRATEGY,
            DocumentType.RISK_ASSESSMENT,
            DocumentType.QUALITY_REPORT
        ]

        for doc_type in required_docs:
            if doc_type in spec.documents and spec.documents[doc_type].content:
                score += 10

        return min(score, 100.0)

    def _calculate_consistency(self, spec: SpecificationDocument) -> float:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è®¡ç®—ä¸€è‡´æ€§å¾—åˆ†

        æ£€æŸ¥é¡¹:
        1. ä¼˜å…ˆçº§åˆ†å¸ƒåˆç†(20åˆ†)
        2. éœ€æ±‚IDå”¯ä¸€ä¸”æ ¼å¼ç»Ÿä¸€(20åˆ†)
        3. ç”¨æˆ·æ•…äº‹IDå”¯ä¸€ä¸”æ ¼å¼ç»Ÿä¸€(20åˆ†)
        4. æœ¯è¯­ä½¿ç”¨ä¸€è‡´(20åˆ†)
        5. ä¾èµ–å…³ç³»æœ‰æ•ˆ(20åˆ†)
        """
        score = 0.0

        # 1. ä¼˜å…ˆçº§åˆ†å¸ƒåˆç† (20åˆ†)
        if spec.user_stories:
            priorities = [story.priority for story in spec.user_stories]
            # æ£€æŸ¥æ˜¯å¦æœ‰å„ç§ä¼˜å…ˆçº§(é¿å…å…¨æ˜¯CRITICALæˆ–å…¨æ˜¯LOW)
            unique_priorities = set(priorities)
            if len(unique_priorities) >= 2:
                score += 20
            elif len(unique_priorities) == 1:
                score += 10

        # 2. éœ€æ±‚IDå”¯ä¸€æ€§ (20åˆ†)
        if spec.requirements:
            req_ids = [req.id for req in spec.requirements]
            if len(req_ids) == len(set(req_ids)):
                score += 20
            else:
                # éƒ¨åˆ†é‡å¤
                unique_ratio = len(set(req_ids)) / len(req_ids)
                score += unique_ratio * 20

        # 3. ç”¨æˆ·æ•…äº‹IDå”¯ä¸€æ€§ (20åˆ†)
        if spec.user_stories:
            story_ids = [story.id for story in spec.user_stories]
            if len(story_ids) == len(set(story_ids)):
                score += 20
            else:
                unique_ratio = len(set(story_ids)) / len(story_ids)
                score += unique_ratio * 20

        # 4. æœ¯è¯­ä¸€è‡´æ€§ (20åˆ†)
        # ç®€å•æ£€æŸ¥:å¦‚æœé¡¹ç›®åç§°åœ¨æè¿°ä¸­å‡ºç°,è¯´æ˜æœ¯è¯­è¾ƒä¸€è‡´
        if spec.requirements:
            project_terms = spec.project_name.lower().split()
            consistent_count = 0
            for req in spec.requirements:
                desc_lower = req.description.lower()
                if any(term in desc_lower for term in project_terms):
                    consistent_count += 1
            if len(spec.requirements) > 0:
                consistency_ratio = consistent_count / len(spec.requirements)
                score += consistency_ratio * 20

        # 5. ä¾èµ–å…³ç³»æœ‰æ•ˆæ€§ (20åˆ†)
        # ç®€å•æ£€æŸ¥:ä¾èµ–çš„IDæ˜¯å¦å­˜åœ¨
        all_req_ids = {req.id for req in spec.requirements} if spec.requirements else set()
        invalid_deps = 0
        total_deps = 0

        if spec.requirements:
            for req in spec.requirements:
                req_deps = getattr(req, 'dependencies', [])
                if req_deps:
                    for dep_id in req_deps:
                        total_deps += 1
                        if dep_id not in all_req_ids:
                            invalid_deps += 1

        if total_deps > 0:
            valid_ratio = (total_deps - invalid_deps) / total_deps
            score += valid_ratio * 20
        else:
            # æ²¡æœ‰ä¾èµ–å…³ç³»,ç»™äºˆæ»¡åˆ†
            score += 20

        return min(score, 100.0)

    def _calculate_atomicity(self, spec: SpecificationDocument) -> float:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è®¡ç®—åŸå­æ€§å¾—åˆ†

        æ£€æŸ¥é¡¹:
        1. éœ€æ±‚æè¿°é•¿åº¦é€‚ä¸­(20åˆ†)
        2. ç”¨æˆ·æ•…äº‹æè¿°ç®€æ´(30åˆ†)
        3. éªŒæ”¶æ ‡å‡†æ˜ç¡®ä¸”å¯é‡åŒ–(30åˆ†)
        4. æ²¡æœ‰å¤åˆéœ€æ±‚(20åˆ†)
        """
        score = 0.0

        # 1. éœ€æ±‚æè¿°é•¿åº¦é€‚ä¸­ (20åˆ†)
        # ç†æƒ³é•¿åº¦:50-200å­—ç¬¦
        if spec.requirements:
            good_length_count = 0
            for req in spec.requirements:
                desc_len = len(req.description)
                if 50 <= desc_len <= 200:
                    good_length_count += 1
                elif 30 <= desc_len <= 300:
                    good_length_count += 0.5

            length_ratio = good_length_count / len(spec.requirements)
            score += length_ratio * 20

        # 2. ç”¨æˆ·æ•…äº‹æè¿°ç®€æ´ (30åˆ†)
        if spec.user_stories:
            concise_count = 0
            for story in spec.user_stories:
                # æ£€æŸ¥ i_want å’Œ so_that æ˜¯å¦ç®€æ´(ä¸è¶…è¿‡100å­—ç¬¦)
                if len(story.i_want) <= 100 and len(story.so_that) <= 100:
                    concise_count += 1

            concise_ratio = concise_count / len(spec.user_stories)
            score += concise_ratio * 30

        # 3. éªŒæ”¶æ ‡å‡†æ˜ç¡® (30åˆ†)
        if spec.user_stories:
            clear_ac_count = 0
            for story in spec.user_stories:
                if story.acceptance_criteria:
                    # æ£€æŸ¥éªŒæ”¶æ ‡å‡†æ•°é‡(2-5ä¸ªè¾ƒåˆç†)
                    ac_count = len(story.acceptance_criteria)
                    if 2 <= ac_count <= 5:
                        clear_ac_count += 1
                    elif ac_count >= 1:
                        clear_ac_count += 0.5

            ac_ratio = clear_ac_count / len(spec.user_stories)
            score += ac_ratio * 30

        # 4. æ²¡æœ‰å¤åˆéœ€æ±‚ (20åˆ†)
        # æ£€æŸ¥æè¿°ä¸­æ˜¯å¦æœ‰"å’Œ","ä»¥åŠ","åŒæ—¶"ç­‰å¤åˆè¯
        if spec.requirements:
            atomic_count = 0
            compound_keywords = ['å’Œ', 'ä»¥åŠ', 'åŒæ—¶', 'å¹¶ä¸”', 'ä»¥åŠ', 'è¿˜è¦', 'å¦å¤–']

            for req in spec.requirements:
                has_compound = any(kw in req.description for kw in compound_keywords)
                if not has_compound:
                    atomic_count += 1

            atomic_ratio = atomic_count / len(spec.requirements)
            score += atomic_ratio * 20

        return min(score, 100.0)

    def _calculate_testability(self, spec: SpecificationDocument) -> float:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        è®¡ç®—å¯æµ‹è¯•æ€§å¾—åˆ†

        æ£€æŸ¥é¡¹:
        1. éªŒæ”¶æ ‡å‡†å¯é‡åŒ–(30åˆ†)
        2. æœ‰æ˜ç¡®çš„è¾“å…¥è¾“å‡º(25åˆ†)
        3. æœ‰æµ‹è¯•ç­–ç•¥æ–‡æ¡£(25åˆ†)
        4. æœ‰æµ‹è¯•ç”¨ä¾‹(20åˆ†)
        """
        score = 0.0

        # 1. éªŒæ”¶æ ‡å‡†å¯é‡åŒ– (30åˆ†)
        # æ£€æŸ¥éªŒæ”¶æ ‡å‡†ä¸­æ˜¯å¦æœ‰å¯é‡åŒ–çš„è¯æ±‡
        quantifiable_keywords = [
            'å¿…é¡»', 'åº”è¯¥', 'èƒ½å¤Ÿ', 'å¯ä»¥', 'æˆåŠŸ', 'å¤±è´¥',
            'æ˜¾ç¤º', 'è¿”å›', 'åŒ…å«', 'ç­‰äº', 'å¤§äº', 'å°äº',
            '<=', '>=', '<', '>', '=', 'ç§’', 'æ¬¡', 'ä¸ª', '%'
        ]

        if spec.user_stories:
            quantifiable_count = 0
            for story in spec.user_stories:
                if story.acceptance_criteria:
                    has_quantifiable = any(
                        any(kw in ac for kw in quantifiable_keywords)
                        for ac in story.acceptance_criteria
                    )
                    if has_quantifiable:
                        quantifiable_count += 1

            if len(spec.user_stories) > 0:
                quant_ratio = quantifiable_count / len(spec.user_stories)
                score += quant_ratio * 30

        # 2. æœ‰æ˜ç¡®çš„è¾“å…¥è¾“å‡º (25åˆ†)
        # æ£€æŸ¥éªŒæ”¶æ ‡å‡†ä¸­æ˜¯å¦æåˆ°è¾“å…¥,è¾“å‡º,Given,When,Then
        io_keywords = ['è¾“å…¥', 'è¾“å‡º', 'Given', 'When', 'Then', 'å‰æ', 'æ“ä½œ', 'ç»“æœ']

        if spec.user_stories:
            io_count = 0
            for story in spec.user_stories:
                if story.acceptance_criteria:
                    has_io = any(
                        any(kw in ac for kw in io_keywords)
                        for ac in story.acceptance_criteria
                    )
                    if has_io:
                        io_count += 1

            if len(spec.user_stories) > 0:
                io_ratio = io_count / len(spec.user_stories)
                score += io_ratio * 25

        # 3. æœ‰æµ‹è¯•ç­–ç•¥æ–‡æ¡£ (25åˆ†)
        from core.models import DocumentType
        if DocumentType.TEST_STRATEGY in spec.documents:
            test_doc = spec.documents[DocumentType.TEST_STRATEGY]
            if test_doc.content and len(test_doc.content) > 500:
                score += 25
            elif test_doc.content:
                score += 15

        # 4. æœ‰æµ‹è¯•ç”¨ä¾‹ (20åˆ†)
        if spec.test_cases:
            if len(spec.test_cases) >= len(spec.user_stories):
                score += 20
            elif len(spec.test_cases) >= len(spec.user_stories) * 0.5:
                score += 15
            elif len(spec.test_cases) >= 1:
                score += 10

        return min(score, 100.0)

    def _collect_validation_issues(self, spec: SpecificationDocument) -> List[ValidationIssue]:
        """
        
        
        Args:
            å‚æ•°å¾…æ–‡æ¡£åŒ–
        
        Returns:
            è¿”å›å€¼å¾…æ–‡æ¡£åŒ–
        """
        æ”¶é›†éªŒè¯é—®é¢˜

        æ£€æŸ¥:
        1. ç¼ºå¤±çš„å¿…è¦ä¿¡æ¯
        2. æ ¼å¼é—®é¢˜
        3. é€»è¾‘é—®é¢˜
        """
        issues = []

        # 1. æ£€æŸ¥é¡¹ç›®åŸºæœ¬ä¿¡æ¯
        if not spec.project_name or spec.project_name == "æœªå‘½åé¡¹ç›®":
            issues.append(ValidationIssue(
                rule_id="R001",
                severity=Severity.HIGH,
                description="é¡¹ç›®åç§°ç¼ºå¤±æˆ–ä½¿ç”¨é»˜è®¤å€¼",
                location="é¡¹ç›®ä¿¡æ¯",
                suggestion="è¯·æä¾›æ˜ç¡®çš„é¡¹ç›®åç§°"
            ))

        # 2. æ£€æŸ¥éœ€æ±‚æ•°é‡
        if not spec.requirements or len(spec.requirements) < 3:
            issues.append(ValidationIssue(
                rule_id="R002",
                severity=Severity.MEDIUM,
                description=f"éœ€æ±‚æ•°é‡åå°‘(å½“å‰{len(spec.requirements)}ä¸ª)",
                location="éœ€æ±‚åˆ—è¡¨",
                suggestion="å»ºè®®è‡³å°‘å®šä¹‰3ä¸ªåŠŸèƒ½éœ€æ±‚"
            ))

        # 3. æ£€æŸ¥ç”¨æˆ·æ•…äº‹æ•°é‡
        if not spec.user_stories or len(spec.user_stories) < 5:
            issues.append(ValidationIssue(
                rule_id="R003",
                severity=Severity.MEDIUM,
                description=f"ç”¨æˆ·æ•…äº‹æ•°é‡åå°‘(å½“å‰{len(spec.user_stories)}ä¸ª)",
                location="ç”¨æˆ·æ•…äº‹",
                suggestion="å»ºè®®è‡³å°‘å®šä¹‰5ä¸ªç”¨æˆ·æ•…äº‹"
            ))

        # 4. æ£€æŸ¥éªŒæ”¶æ ‡å‡†
        if spec.user_stories:
            stories_without_ac = [
                story.id for story in spec.user_stories
                if not story.acceptance_criteria
            ]
            if stories_without_ac:
                issues.append(ValidationIssue(
                    rule_id="R004",
                    severity=Severity.MEDIUM,
                    description=f"{len(stories_without_ac)}ä¸ªç”¨æˆ·æ•…äº‹ç¼ºå°‘éªŒæ”¶æ ‡å‡†",
                    location=f"ç”¨æˆ·æ•…äº‹éªŒæ”¶æ ‡å‡†",
                    suggestion=f"å»ºè®®ä¸ºä»¥ä¸‹æ•…äº‹æ·»åŠ éªŒæ”¶æ ‡å‡†: {', '.join(stories_without_ac[:3])}"
                ))

        # 5. æ£€æŸ¥éœ€æ±‚IDæ ¼å¼
        if spec.requirements:
            invalid_req_ids = [
                req.id for req in spec.requirements
                if not (req.id.startswith('REQ-') or req.id.startswith('FR-') or req.id.startswith('NFR-'))
            ]
            if invalid_req_ids:
                issues.append(ValidationIssue(
                    rule_id="R005",
                    severity=Severity.LOW,
                    description=f"{len(invalid_req_ids)}ä¸ªéœ€æ±‚IDæ ¼å¼ä¸æ ‡å‡†",
                    location="éœ€æ±‚IDæ ¼å¼",
                    suggestion="å»ºè®®ä½¿ç”¨ REQ-xxx,FR-xxx æˆ– NFR-xxx æ ¼å¼"
                ))

        # 6. æ£€æŸ¥ç”¨æˆ·æ•…äº‹IDæ ¼å¼
        if spec.user_stories:
            invalid_story_ids = [
                story.id for story in spec.user_stories
                if not story.id.startswith('US-')
            ]
            if invalid_story_ids:
                issues.append(ValidationIssue(
                    rule_id="R006",
                    severity=Severity.LOW,
                    description=f"{len(invalid_story_ids)}ä¸ªç”¨æˆ·æ•…äº‹IDæ ¼å¼ä¸æ ‡å‡†",
                    location="ç”¨æˆ·æ•…äº‹IDæ ¼å¼",
                    suggestion="å»ºè®®ä½¿ç”¨ US-xxx æ ¼å¼"
                ))

        # 7. æ£€æŸ¥ä¾èµ–å…³ç³»æœ‰æ•ˆæ€§
        if spec.requirements:
            all_req_ids = {req.id for req in spec.requirements}
            for req in spec.requirements:
                req_deps = getattr(req, 'dependencies', [])
                if req_deps:
                    invalid_deps = [
                        dep_id for dep_id in req_deps
                        if dep_id not in all_req_ids
                    ]
                    if invalid_deps:
                        issues.append(ValidationIssue(
                            rule_id="R007",
                            severity=Severity.HIGH,
                            description=f"ä¾èµ–çš„éœ€æ±‚IDä¸å­˜åœ¨: {', '.join(invalid_deps)}",
                            location=f"éœ€æ±‚ {req.id}",
                            suggestion="è¯·æ£€æŸ¥ä¾èµ–å…³ç³»æˆ–æ·»åŠ ç¼ºå¤±çš„éœ€æ±‚"
                        ))

        return issues

    def _generate_recommendations(
        """å¾…æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²"""
        self,
        spec: SpecificationDocument,
        metrics: QualityMetrics,
        issues: List[ValidationIssue]
    ) -> List[str]:
        """
        ç”Ÿæˆæ”¹è¿›å»ºè®®

        åŸºäºè´¨é‡æŒ‡æ ‡å’ŒéªŒè¯é—®é¢˜ç”Ÿæˆé’ˆå¯¹æ€§å»ºè®®
        """
        recommendations = []

        # 1. åŸºäºå®Œæ•´æ€§å¾—åˆ†
        if metrics.completeness_score < 60:
            recommendations.append(
                "ğŸ“‹ **å®Œæ•´æ€§è¾ƒä½**:å»ºè®®è¡¥å……ç¼ºå¤±çš„æ–‡æ¡£å’Œéœ€æ±‚ä¿¡æ¯,ç¡®ä¿é¡¹ç›®ä¿¡æ¯,éœ€æ±‚,ç”¨æˆ·æ•…äº‹ç­‰æ ¸å¿ƒå†…å®¹é½å…¨."
            )
        elif metrics.completeness_score < 80:
            recommendations.append(
                "ğŸ“‹ **å®Œæ•´æ€§ä¸­ç­‰**:å¤§éƒ¨åˆ†å†…å®¹å·²é½å…¨,å»ºè®®è¡¥å……éªŒæ”¶æ ‡å‡†å’Œæµ‹è¯•ç”¨ä¾‹ä»¥æå‡è´¨é‡."
            )

        # 2. åŸºäºä¸€è‡´æ€§å¾—åˆ†
        if metrics.consistency_score < 60:
            recommendations.append(
                "ğŸ”„ **ä¸€è‡´æ€§è¾ƒä½**:å»ºè®®æ£€æŸ¥éœ€æ±‚ID,ç”¨æˆ·æ•…äº‹IDçš„å”¯ä¸€æ€§å’Œæ ¼å¼ç»Ÿä¸€æ€§,ç¡®ä¿ä¾èµ–å…³ç³»æœ‰æ•ˆ."
            )
        elif metrics.consistency_score < 80:
            recommendations.append(
                "ğŸ”„ **ä¸€è‡´æ€§ä¸­ç­‰**:å¤§éƒ¨åˆ†å†…å®¹ä¸€è‡´,å»ºè®®ç»Ÿä¸€æœ¯è¯­ä½¿ç”¨å’Œä¼˜å…ˆçº§åˆ†å¸ƒ."
            )

        # 3. åŸºäºåŸå­æ€§å¾—åˆ†
        if metrics.atomicity_score < 60:
            recommendations.append(
                "âš›ï¸ **åŸå­æ€§è¾ƒä½**:å»ºè®®å°†å¤åˆéœ€æ±‚æ‹†åˆ†ä¸ºç‹¬ç«‹çš„å°éœ€æ±‚,ç¡®ä¿æ¯ä¸ªéœ€æ±‚å’Œç”¨æˆ·æ•…äº‹èŒè´£å•ä¸€."
            )
        elif metrics.atomicity_score < 80:
            recommendations.append(
                "âš›ï¸ **åŸå­æ€§ä¸­ç­‰**:å¤§éƒ¨åˆ†éœ€æ±‚å·²è¶³å¤Ÿç»†åŒ–,å»ºè®®ä¼˜åŒ–éªŒæ”¶æ ‡å‡†ä½¿å…¶æ›´åŠ æ˜ç¡®."
            )

        # 4. åŸºäºå¯æµ‹è¯•æ€§å¾—åˆ†
        if metrics.testability_score < 60:
            recommendations.append(
                "ğŸ§ª **å¯æµ‹è¯•æ€§è¾ƒä½**:å»ºè®®ä¸ºæ¯ä¸ªç”¨æˆ·æ•…äº‹æ·»åŠ æ˜ç¡®çš„,å¯é‡åŒ–çš„éªŒæ”¶æ ‡å‡†,è¡¥å……æµ‹è¯•ç”¨ä¾‹å’Œæµ‹è¯•ç­–ç•¥."
            )
        elif metrics.testability_score < 80:
            recommendations.append(
                "ğŸ§ª **å¯æµ‹è¯•æ€§ä¸­ç­‰**:å¤§éƒ¨åˆ†å†…å®¹å¯æµ‹è¯•,å»ºè®®å¢å¼ºéªŒæ”¶æ ‡å‡†çš„å¯é‡åŒ–æ€§(å¦‚å“åº”æ—¶é—´,é”™è¯¯ç‡ç­‰)."
            )

        # 5. åŸºäºéªŒè¯é—®é¢˜
        high_count = sum(1 for issue in issues if issue.severity == Severity.HIGH or issue.severity == Severity.CRITICAL)
        medium_count = sum(1 for issue in issues if issue.severity == Severity.MEDIUM)

        if high_count > 0:
            recommendations.append(
                f" **å‘ç°{high_count}ä¸ªä¸¥é‡é—®é¢˜**:è¯·ä¼˜å…ˆä¿®å¤é«˜ä¼˜å…ˆçº§é—®é¢˜(å¦‚æ— æ•ˆçš„ä¾èµ–å…³ç³»,ç¼ºå¤±çš„å¿…è¦ä¿¡æ¯)."
            )

        if medium_count > 3:
            recommendations.append(
                f" **å‘ç°{medium_count}ä¸ªè­¦å‘Š**:å»ºè®®é€æ­¥è§£å†³ä¸­ç­‰ä¼˜å…ˆçº§é—®é¢˜ä»¥æå‡æ–‡æ¡£è´¨é‡."
            )

        # 6. åŸºäºæ€»åˆ†ç»™å‡ºæ€»ä½“å»ºè®®
        avg_score = (metrics.completeness_score + metrics.consistency_score +
                    metrics.atomicity_score + metrics.testability_score) / 4

        if avg_score >= 90:
            recommendations.append(
                "ğŸŒŸ **è´¨é‡ä¼˜ç§€**:æ–‡æ¡£è´¨é‡éå¸¸é«˜,å¯ä»¥ç›´æ¥è¿›å…¥å¼€å‘é˜¶æ®µ.å»ºè®®å®šæœŸå›é¡¾å’Œæ›´æ–°æ–‡æ¡£."
            )
        elif avg_score >= 75:
            recommendations.append(
                " **è´¨é‡è‰¯å¥½**:æ–‡æ¡£è´¨é‡è¾ƒå¥½,å¯ä»¥å¼€å§‹å¼€å‘.å»ºè®®åœ¨å¼€å‘è¿‡ç¨‹ä¸­æŒç»­å®Œå–„æ–‡æ¡£."
            )
        elif avg_score >= 60:
            recommendations.append(
                " **è´¨é‡ä¸­ç­‰**:æ–‡æ¡£åŸºæœ¬å¯ç”¨,ä½†å»ºè®®å…ˆè§£å†³ä¸»è¦é—®é¢˜åå†å¼€å§‹å¼€å‘,é¿å…åæœŸè¿”å·¥."
            )
        else:
            recommendations.append(
                " **è´¨é‡åä½**:å»ºè®®å…ˆå®Œå–„æ–‡æ¡£,è¡¥å……ç¼ºå¤±å†…å®¹,è§£å†³å…³é”®é—®é¢˜åå†å¼€å§‹å¼€å‘."
            )

        # 7. ç‰¹å®šé¢†åŸŸå»ºè®®
        if hasattr(spec, 'domain'):
            domain_tips = {
                DomainCategory.FINTECH: "ğŸ’° é‡‘èé¢†åŸŸé¡¹ç›®,å»ºè®®ç‰¹åˆ«å…³æ³¨å®‰å…¨æ€§,åˆè§„æ€§å’Œæ•°æ®ä¸€è‡´æ€§éœ€æ±‚.",
                DomainCategory.HEALTHCARE: "ğŸ¥ åŒ»ç–—é¢†åŸŸé¡¹ç›®,å»ºè®®å…³æ³¨æ‚£è€…éšç§,æ•°æ®å®‰å…¨å’ŒåŒ»ç–—æ ‡å‡†åˆè§„æ€§.",
                DomainCategory.E_COMMERCE: "ğŸ›’ ç”µå•†é¢†åŸŸé¡¹ç›®,å»ºè®®å…³æ³¨æ”¯ä»˜å®‰å…¨,åº“å­˜ç®¡ç†å’Œç”¨æˆ·ä½“éªŒä¼˜åŒ–.",
                DomainCategory.ENTERPRISE: "ğŸ¢ ä¼ä¸šåº”ç”¨é¡¹ç›®,å»ºè®®å…³æ³¨ç³»ç»Ÿé›†æˆ,æƒé™ç®¡ç†å’Œå¯æ‰©å±•æ€§."
            }

            if spec.domain in domain_tips:
                recommendations.append(domain_tips[spec.domain])

        return recommendations

    def _estimate_hours(self, spec: SpecificationDocument) -> int:
        """
        ä¼°ç®—å¼€å‘å·¥æ—¶

        ä¼°ç®—è§„åˆ™:
        - åŸºç¡€å·¥æ—¶:50å°æ—¶
        - æ¯ä¸ªéœ€æ±‚:+5å°æ—¶
        - æ¯ä¸ªç”¨æˆ·æ•…äº‹:+8å°æ—¶
        - å¤æ‚åº¦è°ƒæ•´:Simple 0.8x, Medium 1.0x, Complex 1.3x, Very Complex 1.6x
        - æ–‡æ¡£å®Œæ•´åº¦è°ƒæ•´:æ ¹æ®æ–‡æ¡£æ•°é‡è°ƒæ•´

        Args:
            spec: è§„æ ¼æ–‡æ¡£

        Returns:
            int: ä¼°ç®—å·¥æ—¶
        """
        base_hours = 50

        # éœ€æ±‚å’Œç”¨æˆ·æ•…äº‹
        req_hours = len(spec.requirements) * 5 if spec.requirements else 0
        story_hours = len(spec.user_stories) * 8 if spec.user_stories else 0

        total_hours = base_hours + req_hours + story_hours

        # å¤æ‚åº¦è°ƒæ•´
        if hasattr(spec, 'complexity'):
            complexity_multiplier = {
                ComplexityLevel.SIMPLE: 0.8,
                ComplexityLevel.MEDIUM: 1.0,
                ComplexityLevel.COMPLEX: 1.3,
                ComplexityLevel.VERY_COMPLEX: 1.6
            }
            multiplier = complexity_multiplier.get(spec.complexity, 1.0)
            total_hours = int(total_hours * multiplier)

        # æ–‡æ¡£å®Œæ•´åº¦è°ƒæ•´(æ–‡æ¡£è¶Šå®Œæ•´,å¼€å‘è¶Šå¿«)
        doc_count = len(spec.documents)
        if doc_count >= 7:
            total_hours = int(total_hours * 0.9)  # æ–‡æ¡£é½å…¨,å‡å°‘10%å·¥æ—¶
        elif doc_count <= 3:
            total_hours = int(total_hours * 1.2)  # æ–‡æ¡£ä¸å…¨,å¢åŠ 20%å·¥æ—¶

        return max(total_hours, 20)  # æœ€å°‘20å°æ—¶


# Error handling example
try:
    pass
except Exception:
    pass
