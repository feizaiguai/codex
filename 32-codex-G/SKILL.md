---
name: 32-codex-G
description: All-purpose AI assistant (GPT-5.1 powered) that goes all out to complete tasks. Supports code generation, performance optimization, architecture design, data processing, automation tool development. Auto-selects best strategy, keeps trying until success.
---

# Codex - 全能型 AI 助手

**版本**: 2.0.0
**类型**: 全能型智能助手
**驱动**: GPT-5.1
**核心理念**: 想尽一切办法完成任务

---

## 🎯 核心定位

Codex 是一个**全能型 AI 助手**，不受限于特定任务类型。无论任务多复杂、多困难，Codex 都会：
- ✅ 分析任务，找到最佳解决方案
- ✅ 尝试多种方法，直到成功
- ✅ 遇到障碍时自动切换策略
- ✅ 充分利用所有可用工具和资源
- ✅ 永不放弃，持续优化

---

## 🚀 触发方式

### 自动触发
当提示词中包含 "codex"（不区分大小写）时自动调用。

### 手动触发
```bash
/skill codex
```

### 示例
```
你: "用 codex 帮我完成这个任务"
你: "让 CODEX 解决这个问题"
你: "codex 能处理这个吗"
```

---

## 💪 核心能力

### 1. 智能任务分析
- 自动识别任务类型和难度
- 分解复杂任务为可执行步骤
- 识别潜在障碍和解决方案

### 2. 多策略执行
- **策略 A**: 直接解决（简单任务）
- **策略 B**: 分步解决（中等任务）
- **策略 C**: 多工具组合（复杂任务）
- **策略 D**: 迭代优化（超复杂任务）

### 3. 工具全覆盖
- 📝 代码生成和编辑
- 🔍 代码分析和理解
- 🐛 调试和问题诊断
- 📊 数据分析和处理
- 🧪 测试和验证
- 📚 文档编写
- 🏗️ 架构设计
- 🔧 系统配置
- 🌐 API 集成
- 🤖 自动化脚本
- ⚡ 性能优化
- 🔄 代码重构

### 4. 自适应能力
- 遇到错误自动重试（不同方法）
- 工具不可用时切换备选方案
- 实时调整执行策略
- 从失败中学习优化

---

## 📖 使用场景

### 场景 1: 完整功能开发

**任务**: "用 codex 实现一个完整的用户管理系统"

**执行策略**:
```bash
codex exec <<'EOF'
任务：实现完整的用户管理系统

分析：
1. 需要什么功能？（CRUD、认证、权限、搜索、分页）
2. 使用什么技术？（根据项目上下文选择）
3. 需要什么文件？（models, services, routes, tests, docs）

执行计划：
步骤1: 设计数据模型和数据库schema
步骤2: 实现核心业务逻辑
步骤3: 创建API端点
步骤4: 添加认证和权限控制
步骤5: 编写完整测试
步骤6: 生成API文档

障碍预判：
- 密码安全：使用bcrypt + salt
- JWT管理：实现刷新token机制
- 权限控制：RBAC模式
- 数据验证：输入验证和清洗

开始执行，遇到问题实时调整...
EOF
```

### 场景 2: 复杂问题诊断和修复

**任务**: "codex 帮我找出并修复内存泄漏"

**执行策略**:
```bash
codex exec <<'EOF'
任务：诊断和修复内存泄漏

分析步骤：
1. 收集症状信息（内存增长曲线、触发条件）
2. 分析可能原因（循环引用、事件监听器、闭包）
3. 定位问题代码
4. 设计修复方案
5. 验证修复效果

执行：
方法1: 使用profiler分析内存快照
- 生成heap dump
- 对比不同时间点的内存分配
- 识别持续增长的对象

方法2: 代码静态分析
- 搜索常见泄漏模式
- 检查事件监听器清理
- 审查闭包使用

方法3: 注入调试代码
- 添加内存跟踪
- 记录对象创建和销毁
- 定位未释放的引用

如果方法1不行，尝试方法2...
直到找到根本原因并修复
EOF
```

### 场景 3: 性能优化

**任务**: "codex 优化这个API响应时间到100ms以内"

**执行策略**:
```bash
codex exec <<'EOF'
任务：优化API性能到100ms以内

全面分析：
1. 性能基准测试（当前响应时间）
2. 性能瓶颈识别（profiling）
3. 优化方案设计
4. 实施和验证
5. 持续监控

优化策略：
策略A: 数据库优化
- 添加索引
- 优化查询语句
- 使用查询缓存
- 数据库连接池

策略B: 缓存策略
- Redis缓存热数据
- CDN缓存静态资源
- 应用层缓存
- 浏览器缓存

策略C: 代码优化
- 减少数据库往返次数
- 异步并行处理
- 减少不必要的计算
- 优化算法复杂度

策略D: 架构优化
- 读写分离
- 负载均衡
- 微服务拆分
- 消息队列异步处理

执行顺序：
1. 先用profiler找到瓶颈
2. 从影响最大的优化开始
3. 逐个验证效果
4. 组合使用多种策略
5. 持续测试直到达标
EOF
```

### 场景 4: 架构设计和实现

**任务**: "codex 设计并实现一个可扩展的微服务架构"

**执行策略**:
```bash
codex exec <<'EOF'
任务：设计并实现微服务架构

全面规划：

1. 需求分析
- 业务领域建模
- 识别服务边界
- 确定数据流
- 定义通信模式

2. 架构设计
- 服务拆分策略
- API网关设计
- 服务发现机制
- 配置管理
- 监控和日志
- 容错和降级

3. 技术选型
- 服务框架（Express/Spring/Go）
- 消息队列（RabbitMQ/Kafka）
- 数据库（SQL/NoSQL组合）
- 缓存（Redis）
- 容器化（Docker/K8s）

4. 实施步骤
步骤1: 创建基础设施代码
步骤2: 实现API网关
步骤3: 开发核心服务
步骤4: 配置服务间通信
步骤5: 实现监控和日志
步骤6: 编写部署脚本
步骤7: 集成测试

5. 交付物
- 完整的架构图（Mermaid）
- 服务代码和配置
- Docker编排文件
- 部署文档
- 运维手册

开始执行，每步验证可行性...
EOF
```

### 场景 5: 自动化和工具开发

**任务**: "codex 创建自动化部署流水线"

**执行策略**:
```bash
codex exec <<'EOF'
任务：创建完整的CI/CD自动化流水线

全流程设计：

1. 需求分析
- 代码托管平台（GitHub/GitLab）
- 部署环境（dev/staging/prod）
- 触发条件（push/PR/tag）
- 部署策略（蓝绿/金丝雀/滚动）

2. 流水线阶段
阶段1: 代码检查
- Lint检查
- 安全扫描
- 依赖审计

阶段2: 测试
- 单元测试
- 集成测试
- E2E测试
- 性能测试

阶段3: 构建
- 编译代码
- 打包应用
- 构建容器镜像
- 推送到镜像仓库

阶段4: 部署
- 部署到目标环境
- 健康检查
- 烟雾测试
- 自动回滚

阶段5: 监控
- 部署通知
- 性能监控
- 错误跟踪
- 告警配置

3. 实施
方法A: GitHub Actions
- 创建 .github/workflows/ci-cd.yml
- 配置secrets和环境变量
- 实现各阶段任务

方法B: GitLab CI
- 创建 .gitlab-ci.yml
- 配置runners
- 实现pipeline

方法C: Jenkins
- 创建 Jenkinsfile
- 配置构建节点
- 实现pipeline

选择最适合的平台，完整实现...
EOF
```

### 场景 6: 数据处理和分析

**任务**: "codex 处理这个大数据集并生成分析报告"

**执行策略**:
```bash
codex exec <<'EOF'
任务：处理大数据集并生成分析报告

智能分析：

1. 数据探索
- 检查数据大小和格式
- 识别数据类型和结构
- 发现数据质量问题
- 评估处理复杂度

2. 处理策略选择
如果数据 < 100MB:
- 使用pandas直接处理
- 内存中完成所有操作

如果数据 100MB - 10GB:
- 分块读取（chunk processing）
- 使用Dask并行处理
- 优化内存使用

如果数据 > 10GB:
- 使用PySpark分布式处理
- 数据库ETL流程
- 流式处理

3. 数据处理流程
步骤1: 数据清洗
- 处理缺失值
- 去除重复记录
- 数据类型转换
- 异常值处理

步骤2: 数据转换
- 特征工程
- 聚合统计
- 数据透视
- 时间序列处理

步骤3: 数据分析
- 描述性统计
- 相关性分析
- 趋势分析
- 异常检测

步骤4: 可视化
- 生成图表（matplotlib/plotly）
- 交互式dashboard
- 导出图片

步骤5: 报告生成
- 分析摘要
- 关键发现
- 可视化图表
- 建议和洞察

4. 容错机制
- 自动保存中间结果
- 支持断点续传
- 错误恢复机制

开始执行，根据实际数据调整策略...
EOF
```

### 场景 7: 学习和迁移项目

**任务**: "codex 帮我把这个项目从Python迁移到Go"

**执行策略**:
```bash
codex exec <<'EOF'
任务：将Python项目迁移到Go

系统化方法：

1. 项目分析
- 读取所有源代码
- 理解项目结构
- 识别依赖关系
- 评估迁移难度

2. 技术映射
Python → Go 对应关系：
- Flask/Django → Gin/Echo
- SQLAlchemy → GORM
- requests → net/http
- pytest → testing包
- 异步：asyncio → goroutines

3. 迁移策略
策略1: 逐模块迁移
- 从底层工具函数开始
- 然后是数据模型
- 接着是业务逻辑
- 最后是API层

策略2: 并行开发
- 保持Python版本运行
- 逐步用Go替换组件
- 最后完全切换

4. 执行步骤
步骤1: 设置Go项目结构
- 初始化模块
- 组织目录结构
- 配置依赖管理

步骤2: 迁移数据层
- 定义Go结构体
- 实现数据库访问
- 迁移ORM逻辑

步骤3: 迁移业务逻辑
- 转换Python类到Go结构
- 实现方法和函数
- 处理错误处理差异

步骤4: 迁移API层
- 设置HTTP服务器
- 转换路由定义
- 实现中间件

步骤5: 迁移测试
- 转换测试用例
- 保持测试覆盖率
- 验证功能一致性

步骤6: 性能对比
- 基准测试
- 内存使用对比
- 并发性能测试

5. 质量保证
- 功能对等验证
- 性能提升验证
- 完整的测试套件
- 文档更新

开始迁移，确保每步都可验证...
EOF
```

---

## 🧠 智能策略

### 策略 1: 直接解决（简单任务）
```
识别：任务清晰，步骤明确，无依赖
执行：直接生成解决方案
验证：快速验证结果
```

### 策略 2: 分步解决（中等任务）
```
识别：需要多个步骤，有一定复杂度
执行：
  1. 分解任务
  2. 逐步执行
  3. 每步验证
  4. 继续下一步
```

### 策略 3: 多工具组合（复杂任务）
```
识别：需要多种工具/技能
执行：
  1. 确定需要的工具
  2. 规划工具使用顺序
  3. 执行工具链
  4. 整合结果
```

### 策略 4: 迭代优化（超复杂任务）
```
识别：高度复杂，多个未知因素
执行：
  1. 创建初始解决方案
  2. 测试和评估
  3. 识别问题
  4. 优化改进
  5. 重复2-4直到满意
```

---

## 🔧 执行方式

### 基本调用
```bash
codex exec <<'EOF'
<任务描述>
EOF
```

### 带工作目录
```bash
codex exec --cwd /path/to/project <<'EOF'
<任务描述>
EOF
```

### 文件引用
```bash
codex exec <<'EOF'
分析 @src/main.py 的性能瓶颈并优化
EOF
```

### 持续对话
```bash
# 第一次
codex exec <<'EOF'
任务部分1
EOF
# 保存返回的 session_id

# 第二次（继续）
codex resume <session_id> <<'EOF'
继续任务部分2
EOF
```

### 并行任务
```bash
codex exec --parallel <<'EOF'
---TASK---
id: task1
---CONTENT---
任务1描述

---TASK---
id: task2
dependencies: task1
---CONTENT---
任务2描述（依赖task1）
EOF
```

### 配置参数
- **timeout**: 7200000 毫秒（2小时）
- **output**: 前台模式
- **session**: 支持持续对话
- **parallel**: 支持并行执行

---

## 💡 最佳实践

### ✅ DO（推荐做法）

1. **清晰详细的任务描述**
   ```
   ✅ "实现用户认证API，包含注册、登录、JWT、密码加密、刷新token、测试"
   ❌ "做个登录"
   ```

2. **提供充分的上下文**
   ```
   ✅ "这是一个Node.js + Express项目，使用PostgreSQL数据库"
   ❌ "帮我写代码"
   ```

3. **说明预期结果和标准**
   ```
   ✅ "生成完整可运行的代码，包含测试，测试覆盖率>80%"
   ❌ "写个函数"
   ```

4. **使用@语法引用文件**
   ```
   ✅ "优化 @src/utils.py 中的 process_data 函数"
   ✅ "重构 @src/api/*.js 中的所有API函数"
   ```

5. **信任 Codex 的判断和选择**
   ```
   ✅ "用最佳方案实现，你决定技术选型和实现细节"
   ```

6. **允许探索和调整**
   ```
   ✅ "如果遇到问题，尝试其他方法直到成功"
   ```

7. **利用session机制**
   ```
   ✅ 复杂任务分多次执行，使用resume继续上下文
   ```

### ❌ DON'T（避免做法）

1. **不要过度限制方法**
   ```
   ❌ "只能用这个库，不能用其他的"（除非有特殊原因）
   ✅ "推荐使用这个库，但如果有更好的也可以"
   ```

2. **不要过早放弃**
   ```
   ❌ 第一次失败就停止
   ✅ 让 Codex 尝试多种方法
   ```

3. **不要模糊不清**
   ```
   ❌ "优化一下"
   ✅ "优化性能，目标：响应时间<100ms，内存使用<50MB"
   ```

4. **不要忽略测试**
   ```
   ❌ "只要代码，不要测试"
   ✅ "生成代码和完整的测试套件"
   ```

5. **不要后台运行**
   ```
   ❌ 使用 background: true
   ✅ 始终使用前台模式
   ```

---

## 🎯 解决问题的方法论

### 遇到错误时
```
1. 分析错误信息和堆栈跟踪
2. 识别根本原因
3. 尝试解决方案 A
4. 如果失败 → 分析失败原因 → 尝试方案 B
5. 如果失败 → 调整策略 → 尝试方案 C
6. 如果失败 → 重新评估问题 → 尝试方案 D
7. ...
8. 直到成功或找到可行方案
```

### 任务不清楚时
```
1. 分析可能的多种意图
2. 提出合理假设
3. 按最可能的理解执行
4. 提供多个备选方案
5. 说明选择理由
```

### 资源不足时
```
1. 识别缺少的资源（库/工具/数据）
2. 寻找替代方案
3. 创建临时解决方案
4. 建议长期最佳方案
```

### 性能不足时
```
1. 性能profiling定位瓶颈
2. 评估优化空间
3. 应用优化策略（缓存/索引/算法/架构）
4. 验证优化效果
5. 持续迭代直到达标
```

### 技术限制时
```
1. 识别限制的根本原因
2. 评估可行的技术范围
3. 提供最优可行方案
4. 说明权衡和建议
5. 提供未来改进方向
```

---

## 🌟 高级功能

### 1. 自动依赖管理
```
任务需要某个库 → 自动检测 → 安装或建议安装 → 继续执行
```

### 2. 智能错误恢复
```
执行失败 → 分析原因 → 调整策略 → 尝试新方法 → 重试
```

### 3. 多路径探索
```
复杂问题 → 同时探索多个可能方案 → 评估对比 → 选择最优
```

### 4. 自动性能优化
```
完成任务后 → 分析性能 → 识别优化点 → 提供优化建议 → 可选自动优化
```

### 5. 代码质量保证
```
生成代码时 → 自动应用最佳实践 → 添加测试 → 文档注释 → 错误处理
```

### 6. 智能重构
```
分析代码 → 识别坏味道 → 提出重构方案 → 安全重构 → 验证功能一致
```

### 7. 安全审计
```
自动检测安全漏洞 → SQL注入 → XSS → CSRF → 提供修复方案
```

---

## 📊 输出格式

Codex 根据任务类型自动选择输出格式：

### 代码任务
```python
# 文件: src/auth.py
# 完整的可运行代码
# 包含详细注释和文档字符串

def authenticate_user(username: str, password: str) -> dict:
    """
    用户认证函数

    Args:
        username: 用户名
        password: 密码

    Returns:
        dict: 包含token和用户信息

    Raises:
        AuthenticationError: 认证失败时
    """
    # 实现...
```

### 分析任务
```json
{
  "summary": "分析摘要",
  "findings": [
    {
      "type": "performance",
      "severity": "high",
      "location": "src/api.py:42",
      "issue": "数据库N+1查询问题",
      "recommendation": "使用join或预加载"
    }
  ],
  "recommendations": [
    "建议1：添加数据库索引",
    "建议2：实现查询缓存"
  ],
  "metrics": {
    "current_performance": "500ms",
    "target_performance": "100ms",
    "improvement_potential": "80%"
  }
}
```

### 设计任务
```markdown
# 系统架构设计

## 概述
微服务架构，支持水平扩展...

## 组件清单
1. API Gateway - Nginx
2. User Service - Node.js
3. Order Service - Go
...

## 数据流
```mermaid
graph LR
    Client --> Gateway
    Gateway --> UserService
    Gateway --> OrderService
```

## 技术选型理由
...
```

### 问题诊断
```markdown
## 问题诊断报告

### 问题描述
应用内存持续增长，最终导致OOM

### 根本原因
事件监听器未正确移除，导致闭包引用无法释放

### 证据
- Line 45: addEventListener without removeEventListener
- Memory profile显示EventListener对象持续增长

### 解决方案
1. 添加组件卸载时的清理逻辑
2. 使用WeakMap存储事件引用
3. 实现自动清理机制

### 修复代码
[完整代码...]

### 验证
修复后内存保持稳定，无增长趋势
```

---

## 🔄 与 Gemini 协作

Codex 和 Gemini 可以协同工作：

```
场景1: 完整开发流程
1. Codex: 实现功能代码
2. Gemini: 代码审查和优化建议
3. Codex: 应用优化建议
4. Gemini: 最终验证

场景2: 复杂系统开发
1. Gemini: 架构设计和规划
2. Codex: 具体实现
3. Gemini: 集成测试和验证
4. Codex: 修复问题

场景3: 问题解决
1. Gemini: 问题诊断和分析
2. Codex: 实施修复
3. Gemini: 验证修复效果
4. Codex: 优化和完善

场景4: 性能优化
1. Codex: 性能分析和瓶颈识别
2. Gemini: 优化策略制定
3. Codex: 实施优化
4. Gemini: 效果验证
```

---

## 💰 成本说明

- Codex 使用 GPT-5.1 模型
- 成本约为 Claude Sonnet 的 50%
- 适合各类开发任务，性价比高
- 复杂任务可能需要更多时间，但会确保完成

---

## 🎉 总结

**Codex = 全能型 AI 助手**

- 🎯 **核心理念**: 想尽一切办法完成任务
- 💪 **能力覆盖**: 开发、测试、优化、架构、运维...
- 🧠 **智能决策**: 自动选择最佳策略
- 🔄 **自适应**: 遇到障碍自动调整
- ✅ **可靠性**: 持续尝试直到成功
- 🚀 **高效率**: GPT-5.1驱动，快速响应

**使用场景**: 任何需要 AI 帮助的开发任务

**核心承诺**: 交给 Codex，它会想办法完成

---

**版本**: 2.0.0
**类型**: 全能型智能助手
**状态**: 生产就绪 ✅
