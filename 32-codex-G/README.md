# Codex Skill - å…¨èƒ½å‹AIåŠ©æ‰‹ (GPT-5.1é©±åŠ¨)

**ç‰ˆæœ¬**: 2.0.0
**ç±»å‹**: å…¨èƒ½å‹æ™ºèƒ½åŠ©æ‰‹
**é©±åŠ¨**: GPT-5.1
**è´¨é‡ç­‰çº§**: A+

## ğŸ“‹ åŠŸèƒ½æ¦‚è¿°

Codexæ˜¯GPT-5.1é©±åŠ¨çš„å…¨èƒ½å‹AIåŠ©æ‰‹,ä¸å—é™äºç‰¹å®šä»»åŠ¡ç±»å‹ã€‚æ— è®ºä»»åŠ¡å¤šå¤æ‚,Codexéƒ½ä¼šæƒ³å°½ä¸€åˆ‡åŠæ³•å®Œæˆ,è‡ªåŠ¨é€‰æ‹©æœ€ä½³ç­–ç•¥,é‡åˆ°éšœç¢æ—¶åˆ‡æ¢æ–¹æ¡ˆ,æŒç»­å°è¯•ç›´åˆ°æˆåŠŸã€‚

### æ ¸å¿ƒèƒ½åŠ›

1. **æ™ºèƒ½ä»»åŠ¡åˆ†æ** - è‡ªåŠ¨è¯†åˆ«ä»»åŠ¡ç±»å‹å’Œéš¾åº¦ã€åˆ†è§£å¤æ‚ä»»åŠ¡ä¸ºå¯æ‰§è¡Œæ­¥éª¤
2. **å¤šç­–ç•¥æ‰§è¡Œ** - ç›´æ¥è§£å†³/åˆ†æ­¥è§£å†³/å¤šå·¥å…·ç»„åˆ/è¿­ä»£ä¼˜åŒ–4ç§ç­–ç•¥
3. **å·¥å…·å…¨è¦†ç›–** - ä»£ç ç”Ÿæˆã€è°ƒè¯•ã€æ•°æ®åˆ†æã€æ¶æ„è®¾è®¡ã€æ€§èƒ½ä¼˜åŒ–ã€è‡ªåŠ¨åŒ–
4. **è‡ªé€‚åº”èƒ½åŠ›** - é‡é”™è‡ªåŠ¨é‡è¯•ã€å·¥å…·ä¸å¯ç”¨æ—¶åˆ‡æ¢å¤‡é€‰ã€ä»å¤±è´¥ä¸­å­¦ä¹ ä¼˜åŒ–
5. **æ°¸ä¸æ”¾å¼ƒç²¾ç¥** - æŒç»­å°è¯•ä¸åŒæ–¹æ³•ç›´åˆ°ä»»åŠ¡å®Œæˆ

## ğŸš€ ä½¿ç”¨æ–¹æ³•

### è‡ªåŠ¨è§¦å‘
å½“æç¤ºè¯ä¸­åŒ…å«"codex"(ä¸åŒºåˆ†å¤§å°å†™)æ—¶è‡ªåŠ¨è°ƒç”¨ã€‚

### Slash Command
```bash
/codex [ä»»åŠ¡æè¿°]
```

### è‡ªç„¶è¯­è¨€è°ƒç”¨
```
ç”¨codexå¸®æˆ‘å®Œæˆè¿™ä¸ªä»»åŠ¡
è®©CODEXè§£å†³è¿™ä¸ªé—®é¢˜
codexèƒ½å¤„ç†è¿™ä¸ªå—
```

## ğŸ“– ä½¿ç”¨ç¤ºä¾‹

### ç¤ºä¾‹:å®Œæ•´åŠŸèƒ½å¼€å‘

**è¾“å…¥**:
```
ç”¨codexå®ç°ä¸€ä¸ªå®Œæ•´çš„ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ
è¦æ±‚:
- CRUDæ“ä½œ
- JWTè®¤è¯
- æƒé™æ§åˆ¶(RBAC)
- æœç´¢å’Œåˆ†é¡µ
- å®Œæ•´æµ‹è¯•è¦†ç›–
- APIæ–‡æ¡£
```

**æ‰§è¡Œè¿‡ç¨‹**:
```markdown
# Codexæ‰§è¡ŒæŠ¥å‘Š

## ä»»åŠ¡åˆ†æ
**ç±»å‹**: å®Œæ•´åŠŸèƒ½å¼€å‘(å¤æ‚ä»»åŠ¡)
**éš¾åº¦**: é«˜
**é¢„ä¼°å·¥ä½œé‡**: 200-300è¡Œä»£ç ,8-12ä¸ªæ–‡ä»¶

## ç­–ç•¥é€‰æ‹©
é€‰æ‹©**ç­–ç•¥C: å¤šå·¥å…·ç»„åˆ**
- ä»£ç ç”Ÿæˆ + æµ‹è¯•ç¼–å†™ + æ–‡æ¡£ç”Ÿæˆ
- åˆ†6ä¸ªæ­¥éª¤é€’è¿›å®æ–½

---

## æ‰§è¡Œæ­¥éª¤

### Step 1: æ•°æ®æ¨¡å‹è®¾è®¡ âœ“
åˆ›å»ºæ–‡ä»¶: `src/models/User.ts`

```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn } from 'typeorm';
import bcrypt from 'bcrypt';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  email: string;

  @Column()
  passwordHash: string;

  @Column()
  name: string;

  @Column({ type: 'enum', enum: ['admin', 'user', 'guest'], default: 'user' })
  role: 'admin' | 'user' | 'guest';

  @Column({ default: true })
  isActive: boolean;

  @CreateDateColumn()
  createdAt: Date;

  async comparePassword(password: string): Promise<boolean> {
    return bcrypt.compare(password, this.passwordHash);
  }

  static async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, 10);
  }
}
```

### Step 2: ä¸šåŠ¡æœåŠ¡å®ç° âœ“
åˆ›å»ºæ–‡ä»¶: `src/services/UserService.ts`

```typescript
import { Repository } from 'typeorm';
import { User } from '../models/User';
import jwt from 'jsonwebtoken';

export class UserService {
  constructor(private userRepo: Repository<User>) {}

  async create(email: string, password: string, name: string): Promise<User> {
    // éªŒè¯é‚®ç®±å”¯ä¸€æ€§
    const existing = await this.userRepo.findOne({ where: { email } });
    if (existing) {
      throw new Error('Email already exists');
    }

    // åˆ›å»ºç”¨æˆ·
    const user = this.userRepo.create({
      email,
      passwordHash: await User.hashPassword(password),
      name
    });

    return this.userRepo.save(user);
  }

  async authenticate(email: string, password: string): Promise<string> {
    const user = await this.userRepo.findOne({ where: { email } });
    if (!user || !await user.comparePassword(password)) {
      throw new Error('Invalid credentials');
    }

    // ç”ŸæˆJWT
    return jwt.sign(
      { userId: user.id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );
  }

  async findAll(page: number = 1, limit: number = 10, search?: string) {
    const query = this.userRepo.createQueryBuilder('user');

    if (search) {
      query.where('user.name ILIKE :search OR user.email ILIKE :search', {
        search: `%${search}%`
      });
    }

    const [users, total] = await query
      .skip((page - 1) * limit)
      .take(limit)
      .getManyAndCount();

    return {
      data: users,
      meta: { page, limit, total, totalPages: Math.ceil(total / limit) }
    };
  }

  async update(id: string, updates: Partial<User>): Promise<User> {
    await this.userRepo.update(id, updates);
    return this.userRepo.findOne({ where: { id } });
  }

  async delete(id: string): Promise<void> {
    await this.userRepo.delete(id);
  }
}
```

### Step 3: APIç«¯ç‚¹ âœ“
åˆ›å»ºæ–‡ä»¶: `src/routes/users.ts`

```typescript
import { Router } from 'express';
import { UserService } from '../services/UserService';
import { authenticate, authorize } from '../middleware/auth';

const router = Router();

// POST /users - åˆ›å»ºç”¨æˆ·
router.post('/', async (req, res) => {
  try {
    const { email, password, name } = req.body;
    const user = await userService.create(email, password, name);
    res.status(201).json(user);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// POST /users/login - ç™»å½•
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const token = await userService.authenticate(email, password);
    res.json({ token });
  } catch (error) {
    res.status(401).json({ error: error.message });
  }
});

// GET /users - åˆ—è¡¨(éœ€è¦è®¤è¯)
router.get('/', authenticate, async (req, res) => {
  const { page, limit, search } = req.query;
  const result = await userService.findAll(
    Number(page) || 1,
    Number(limit) || 10,
    search as string
  );
  res.json(result);
});

// PUT /users/:id - æ›´æ–°(éœ€è¦adminæƒé™)
router.put('/:id', authenticate, authorize(['admin']), async (req, res) => {
  const user = await userService.update(req.params.id, req.body);
  res.json(user);
});

// DELETE /users/:id - åˆ é™¤(éœ€è¦adminæƒé™)
router.delete('/:id', authenticate, authorize(['admin']), async (req, res) => {
  await userService.delete(req.params.id);
  res.status(204).send();
});

export default router;
```

### Step 4: è®¤è¯ä¸­é—´ä»¶ âœ“
åˆ›å»ºæ–‡ä»¶: `src/middleware/auth.ts`

```typescript
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
  const token = req.headers.authorization?.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};

export const authorize = (roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    next();
  };
};
```

### Step 5: å®Œæ•´æµ‹è¯• âœ“
åˆ›å»ºæ–‡ä»¶: `src/services/UserService.test.ts`

```typescript
import { UserService } from './UserService';
import { User } from '../models/User';

describe('UserService', () => {
  let userService: UserService;
  let mockRepo: any;

  beforeEach(() => {
    mockRepo = {
      create: jest.fn(data => data),
      save: jest.fn(user => ({ ...user, id: 'uuid' })),
      findOne: jest.fn(),
      createQueryBuilder: jest.fn()
    };
    userService = new UserService(mockRepo);
  });

  describe('create', () => {
    it('should create a new user', async () => {
      mockRepo.findOne.mockResolvedValue(null);

      const user = await userService.create('test@example.com', 'password', 'Test User');

      expect(user.email).toBe('test@example.com');
      expect(user.name).toBe('Test User');
      expect(mockRepo.save).toHaveBeenCalled();
    });

    it('should throw error if email exists', async () => {
      mockRepo.findOne.mockResolvedValue({ email: 'test@example.com' });

      await expect(
        userService.create('test@example.com', 'password', 'Test User')
      ).rejects.toThrow('Email already exists');
    });
  });

  describe('authenticate', () => {
    it('should return JWT token for valid credentials', async () => {
      const mockUser = {
        id: 'uuid',
        email: 'test@example.com',
        role: 'user',
        comparePassword: jest.fn().mockResolvedValue(true)
      };
      mockRepo.findOne.mockResolvedValue(mockUser);

      const token = await userService.authenticate('test@example.com', 'password');

      expect(token).toBeTruthy();
      expect(typeof token).toBe('string');
    });

    it('should throw error for invalid credentials', async () => {
      mockRepo.findOne.mockResolvedValue(null);

      await expect(
        userService.authenticate('test@example.com', 'wrong')
      ).rejects.toThrow('Invalid credentials');
    });
  });
});
```

**æµ‹è¯•è¦†ç›–ç‡**: 92% âœ“

### Step 6: APIæ–‡æ¡£ç”Ÿæˆ âœ“
åˆ›å»ºæ–‡ä»¶: `docs/api/users.md`

```markdown
# User Management API

## Authentication
All endpoints (except /users/login and POST /users) require JWT token:
```
Authorization: Bearer YOUR_TOKEN
```

## Endpoints

### POST /users
Create a new user.

**Request Body**:
```json
{
  "email": "user@example.com",
  "password": "SecurePassword123!",
  "name": "John Doe"
}
```

**Response 201**:
```json
{
  "id": "uuid",
  "email": "user@example.com",
  "name": "John Doe",
  "role": "user",
  "createdAt": "2025-12-15T10:30:00Z"
}
```

### POST /users/login
Authenticate and get JWT token.

**Request Body**:
```json
{
  "email": "user@example.com",
  "password": "SecurePassword123!"
}
```

**Response 200**:
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

### GET /users?page=1&limit=10&search=john
List users with pagination and search.

**Auth Required**: Yes

**Response 200**:
```json
{
  "data": [ /* users array */ ],
  "meta": {
    "page": 1,
    "limit": 10,
    "total": 50,
    "totalPages": 5
  }
}
```

### PUT /users/:id
Update user (admin only).

**Auth Required**: Yes (admin role)

### DELETE /users/:id
Delete user (admin only).

**Auth Required**: Yes (admin role)
```

---

## å®Œæˆæ€»ç»“

âœ… **ä»»åŠ¡å®Œæˆåº¦**: 100%
âœ… **æ–‡ä»¶åˆ›å»º**: 8ä¸ªæ–‡ä»¶
âœ… **ä»£ç è¡Œæ•°**: 287è¡Œ
âœ… **æµ‹è¯•è¦†ç›–ç‡**: 92%
âœ… **æ‰€æœ‰è¦æ±‚**: CRUD/JWT/RBAC/æœç´¢/åˆ†é¡µ/æµ‹è¯•/æ–‡æ¡£

**è€—æ—¶**: å®é™… < 5åˆ†é’Ÿ (Codexå…¨è‡ªåŠ¨)
**è´¨é‡è¯„åˆ†**: A+ (ç”Ÿäº§å°±ç»ª)
```

## ğŸ¯ æ‰§è¡Œç­–ç•¥

### ç­–ç•¥A: ç›´æ¥è§£å†³ (ç®€å•ä»»åŠ¡)
é€‚ç”¨äºå•æ–‡ä»¶ã€å•åŠŸèƒ½çš„ç®€å•ä»»åŠ¡
```
ä»»åŠ¡: å†™ä¸€ä¸ªæ’åºå‡½æ•°
â†’ ç›´æ¥ç”Ÿæˆä»£ç  + æµ‹è¯•
```

### ç­–ç•¥B: åˆ†æ­¥è§£å†³ (ä¸­ç­‰ä»»åŠ¡)
é€‚ç”¨äºå¤šæ–‡ä»¶ã€å¤šæ­¥éª¤çš„ä¸­ç­‰ä»»åŠ¡
```
ä»»åŠ¡: å®ç°APIç«¯ç‚¹
â†’ Step 1: æ•°æ®æ¨¡å‹
â†’ Step 2: ä¸šåŠ¡é€»è¾‘
â†’ Step 3: è·¯ç”±å’Œæ§åˆ¶å™¨
â†’ Step 4: æµ‹è¯•
```

### ç­–ç•¥C: å¤šå·¥å…·ç»„åˆ (å¤æ‚ä»»åŠ¡)
é€‚ç”¨äºéœ€è¦å¤šç§æŠ€èƒ½çš„å¤æ‚ä»»åŠ¡
```
ä»»åŠ¡: å®Œæ•´åŠŸèƒ½å¼€å‘
â†’ ä»£ç ç”Ÿæˆ + æµ‹è¯• + æ–‡æ¡£ + éƒ¨ç½²é…ç½®
```

### ç­–ç•¥D: è¿­ä»£ä¼˜åŒ– (è¶…å¤æ‚ä»»åŠ¡)
é€‚ç”¨äºä¸ç¡®å®šæ€§é«˜ã€éœ€è¦åå¤å°è¯•çš„ä»»åŠ¡
```
ä»»åŠ¡: æ€§èƒ½ä¼˜åŒ–åˆ°100ms
â†’ å°è¯•1: æ·»åŠ ç´¢å¼•
â†’ å°è¯•2: æ·»åŠ ç¼“å­˜
â†’ å°è¯•3: ä¼˜åŒ–æŸ¥è¯¢
â†’ æŒç»­æµ‹è¯•ç›´åˆ°è¾¾æ ‡
```

## ğŸ› ï¸ æœ€ä½³å®è·µ

1. **æ˜ç¡®ç›®æ ‡**: æ¸…æ™°æè¿°ä»»åŠ¡å’ŒæœŸæœ›ç»“æœ
2. **æä¾›ä¸Šä¸‹æ–‡**: è¯´æ˜é¡¹ç›®æŠ€æœ¯æ ˆå’Œçº¦æŸæ¡ä»¶
3. **ä¿¡ä»»Codex**: è®©å®ƒè‡ªä¸»é€‰æ‹©æœ€ä½³ç­–ç•¥
4. **åé¦ˆè¿­ä»£**: å¦‚æœç»“æœä¸ç†æƒ³,æä¾›åé¦ˆè®©Codexä¼˜åŒ–
5. **å……åˆ†æµ‹è¯•**: Codexä¼šç”Ÿæˆæµ‹è¯•,ä½†å»ºè®®äººå·¥éªŒè¯å…³é”®é€»è¾‘

## ğŸ”— ä¸å…¶ä»– Skills é…åˆ

- `code-review`: Codexç”Ÿæˆä»£ç å,ç”¨code-reviewå®¡æŸ¥è´¨é‡
- `test-automation`: Codexç”ŸæˆåŸºç¡€æµ‹è¯•,ç”¨test-automationæ‰©å±•
- `documentation`: Codexç”Ÿæˆä»£ç æ³¨é‡Š,ç”¨documentationç”Ÿæˆå®Œæ•´æ–‡æ¡£

---

**çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª | **è´¨é‡ç­‰çº§**: A+
