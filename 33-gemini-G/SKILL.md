---
name: 33-gemini-G
description: All-purpose AI assistant that goes all out to complete tasks. Supports code development, problem diagnosis, data processing, architecture design, automation. Auto-selects best strategy, adjusts when blocked, keeps trying until success.
---

# Gemini - 全能型 AI 助手

**版本**: 2.0.0
**类型**: 全能型智能助手
**驱动**: Google Gemini 3 Pro
**核心理念**: 想尽一切办法完成任务

---

## 🎯 核心定位

Gemini 是一个**全能型 AI 助手**，不受限于特定任务类型。无论任务多复杂、多困难，Gemini 都会：
- ✅ 分析任务，找到最佳解决方案
- ✅ 尝试多种方法，直到成功
- ✅ 遇到障碍时自动切换策略
- ✅ 充分利用所有可用工具和资源
- ✅ 永不放弃，持续优化

---

## 🚀 触发方式

### 自动触发
当提示词中包含 "gemini"（不区分大小写）时自动调用。

### 手动触发
```bash
/skill gemini
```

### 示例
```
你: "用 gemini 帮我完成这个任务"
你: "让 GEMINI 解决这个问题"
你: "gemini 能处理这个吗"
```

---

## 💪 核心能力

### 1. 智能任务分析
- 自动识别任务类型和难度
- 分解复杂任务为可执行步骤
- 识别潜在障碍和解决方案

### 2. 多策略执行
- **策略 A**: 直接解决（简单任务）
- **策略 B**: 分步解决（中等任务）
- **策略 C**: 多工具组合（复杂任务）
- **策略 D**: 迭代优化（超复杂任务）

### 3. 工具全覆盖
- 📝 代码生成和编辑
- 🔍 代码审查和分析
- 🐛 调试和问题诊断
- 📊 数据分析和处理
- 🧪 测试和验证
- 📚 文档编写
- 🏗️ 架构设计
- 🔧 系统配置
- 🌐 API 集成
- 🤖 自动化脚本

### 4. 自适应能力
- 遇到错误自动重试（不同方法）
- 工具不可用时切换备选方案
- 实时调整执行策略
- 从失败中学习优化

---

## 📖 使用场景

### 场景 1: 代码开发

**任务**: "用 gemini 实现一个用户认证系统"

**执行策略**:
```bash
gemini -o stream-json <<'EOF'
任务：实现完整的用户认证系统

分析：
1. 需要什么功能？（注册、登录、JWT、密码加密）
2. 使用什么技术？（根据项目上下文选择）
3. 需要什么文件？（models, services, routes, tests）

执行计划：
步骤1: 创建数据模型
步骤2: 实现认证服务
步骤3: 创建API端点
步骤4: 编写单元测试
步骤5: 集成测试

障碍预判：
- 密码加密：使用bcrypt
- JWT生成：使用标准库
- 数据库连接：检查现有配置

开始执行，遇到问题实时调整...
EOF
```

### 场景 2: 问题诊断

**任务**: "gemini 帮我找出为什么程序崩溃"

**执行策略**:
```bash
gemini -o stream-json <<'EOF'
任务：诊断程序崩溃原因

分析步骤：
1. 检查错误日志
2. 分析堆栈跟踪
3. 审查相关代码
4. 识别可能的原因
5. 验证假设
6. 提供解决方案

执行：
- 读取日志文件
- 分析错误模式
- 定位问题代码
- 提供修复建议
- 验证修复有效性

如果第一种方法不行，尝试：
- 方法2: 添加调试日志
- 方法3: 二分法隔离问题
- 方法4: 对比正常版本
EOF
```

### 场景 3: 数据处理

**任务**: "gemini 处理这个 CSV 文件，生成报表"

**执行策略**:
```bash
gemini -o stream-json <<'EOF'
任务：处理 CSV 数据并生成报表

智能分析：
1. 检查CSV文件结构
2. 识别数据类型
3. 确定统计需求
4. 选择最佳工具（pandas/原生/其他）

执行方案：
- 读取和验证数据
- 清洗和转换
- 统计分析
- 生成可视化
- 导出报表

容错机制：
- 数据格式错误 → 自动修正
- 缺失值 → 智能填充
- 异常值 → 标记和处理
EOF
```

### 场景 4: 架构设计

**任务**: "gemini 设计一个可扩展的微服务架构"

**执行策略**:
```bash
gemini -o stream-json <<'EOF'
任务：设计微服务架构

全面分析：
1. 业务需求分析
2. 技术栈选型
3. 服务拆分策略
4. 通信机制设计
5. 数据一致性方案
6. 监控和日志
7. 部署策略

输出：
- 架构图（Markdown/Mermaid）
- 服务清单和职责
- API 契约定义
- 数据流设计
- 部署配置
- 最佳实践文档

迭代优化：
- 评审架构合理性
- 识别潜在瓶颈
- 优化设计
- 提供备选方案
EOF
```

### 场景 5: 复杂问题解决

**任务**: "gemini 这个项目无法启动，帮我修复"

**执行策略**:
```bash
gemini -o stream-json <<'EOF'
任务：诊断并修复项目启动问题

系统化诊断：

步骤1: 信息收集
- 错误消息是什么？
- 什么时候开始的？
- 最近有什么变更？
- 环境配置如何？

步骤2: 快速尝试（常见问题）
- 依赖安装：npm install / pip install
- 环境变量：检查 .env
- 端口占用：检查端口冲突
- 权限问题：检查文件权限

步骤3: 深度诊断
- 检查配置文件
- 分析依赖冲突
- 审查启动脚本
- 验证数据库连接

步骤4: 逐个排除
- 方法1不行 → 尝试方法2
- 方法2不行 → 尝试方法3
- ...
- 直到找到根本原因

步骤5: 修复和验证
- 应用修复
- 测试启动
- 验证功能
- 文档问题和解决方案
EOF
```

### 场景 6: 自动化任务

**任务**: "gemini 自动化部署流程"

**执行策略**:
```bash
gemini -o stream-json <<'EOF'
任务：创建自动化部署流程

全流程设计：

1. 需求分析
- 部署频率？
- 环境数量？（dev/staging/prod）
- 技术栈？
- CI/CD 工具？

2. 流程设计
- 代码检查 → 测试 → 构建 → 部署
- 回滚策略
- 监控和告警

3. 实现
- CI/CD 配置文件
- 部署脚本
- 健康检查
- 自动回滚

4. 工具选择
- GitHub Actions / GitLab CI / Jenkins
- Docker / K8s
- 根据实际情况选择

5. 测试和优化
- 模拟部署
- 性能优化
- 错误处理
EOF
```

---

## 🧠 智能策略

### 策略 1: 直接解决（简单任务）
```
识别：任务清晰，步骤明确，无依赖
执行：直接生成解决方案
验证：快速验证结果
```

### 策略 2: 分步解决（中等任务）
```
识别：需要多个步骤，有一定复杂度
执行：
  1. 分解任务
  2. 逐步执行
  3. 每步验证
  4. 继续下一步
```

### 策略 3: 多工具组合（复杂任务）
```
识别：需要多种工具/技能
执行：
  1. 确定需要的工具
  2. 规划工具使用顺序
  3. 执行工具链
  4. 整合结果
```

### 策略 4: 迭代优化（超复杂任务）
```
识别：高度复杂，多个未知因素
执行：
  1. 创建初始解决方案
  2. 测试和评估
  3. 识别问题
  4. 优化改进
  5. 重复2-4直到满意
```

---

## 🔧 执行方式

### 基本调用
```bash
gemini -o stream-json <<'EOF'
<任务描述>
EOF
```

### 带代理（中国地区）
```bash
HTTP_PROXY=http://127.0.0.1:7890 HTTPS_PROXY=http://127.0.0.1:7890 gemini -o stream-json <<'EOF'
<任务描述>
EOF
```

### 持续对话
```bash
# 第一次
gemini -o stream-json <<'EOF'
任务部分1
EOF
# 保存返回的 session_id

# 第二次（继续）
export SESSION_ID=<previous_session_id>
gemini -o stream-json <<'EOF'
继续任务部分2
EOF
```

### 配置参数
- **timeout**: 300000 毫秒（5分钟）
- **output**: stream-json
- **代理**: 自动检测或手动配置
- **sandbox**: 启用

---

## 💡 最佳实践

### ✅ DO（推荐做法）

1. **清晰描述任务**
   ```
   ✅ "实现用户认证，包括注册、登录、JWT、密码加密"
   ❌ "做个登录"
   ```

2. **提供上下文**
   ```
   ✅ "这是一个 Node.js 项目，使用 Express 框架"
   ❌ "帮我写代码"
   ```

3. **说明预期结果**
   ```
   ✅ "生成可以直接运行的完整代码，包含测试"
   ❌ "写个函数"
   ```

4. **信任 Gemini 的判断**
   ```
   ✅ "用最佳方案实现，你决定技术选型"
   ```

5. **允许尝试和调整**
   ```
   ✅ "如果遇到问题，尝试其他方法"
   ```

### ❌ DON'T（避免做法）

1. **不要限制方法**
   ```
   ❌ "只能用这个库"（除非有特殊原因）
   ✅ "推荐使用这个库，但如果有更好的也可以"
   ```

2. **不要过早放弃**
   ```
   ❌ 第一次失败就停止
   ✅ 让 Gemini 尝试多种方法
   ```

3. **不要模糊描述**
   ```
   ❌ "优化一下"
   ✅ "优化性能，目标是响应时间 < 100ms"
   ```

---

## 🎯 解决问题的方法论

### 遇到错误时
```
1. 分析错误信息
2. 识别根本原因
3. 尝试解决方案 A
4. 如果失败 → 尝试方案 B
5. 如果失败 → 尝试方案 C
6. ...
7. 直到成功或找到可行方案
```

### 任务不清楚时
```
1. 分析可能的意图
2. 提出假设
3. 按最可能的理解执行
4. 提供多个备选方案
```

### 资源不足时
```
1. 识别缺少的资源
2. 寻找替代方案
3. 创建临时解决方案
4. 建议长期方案
```

### 技术限制时
```
1. 识别限制原因
2. 评估可行的范围
3. 提供最优解决方案
4. 说明权衡和建议
```

---

## 🌟 高级功能

### 1. 自动依赖管理
```
任务需要某个库 → 自动安装或建议安装
```

### 2. 智能错误恢复
```
执行失败 → 分析原因 → 调整策略 → 重试
```

### 3. 多路径探索
```
复杂问题 → 同时探索多个可能方案 → 选择最优
```

### 4. 性能优化
```
完成任务后 → 自动分析性能 → 提供优化建议
```

### 5. 最佳实践应用
```
生成代码时 → 自动应用行业最佳实践
```

---

## 📊 输出格式

Gemini 根据任务类型自动选择输出格式：

### 代码任务
```python
# 文件: src/auth.py
# 完整的可运行代码
# 包含注释和文档

def authenticate_user(username, password):
    """用户认证函数"""
    # 实现...
```

### 分析任务
```json
{
  "summary": "分析摘要",
  "findings": ["发现1", "发现2"],
  "recommendations": ["建议1", "建议2"],
  "next_steps": ["步骤1", "步骤2"]
}
```

### 设计任务
```markdown
# 架构设计

## 概述
...

## 组件
...

## 数据流
...
```

---

## 🔄 与 Codex 协作

Gemini 和 Codex 可以协同工作：

```
场景1: 复杂项目开发
1. Gemini: 整体架构设计和规划
2. Codex: 具体代码实现
3. Gemini: 审查和优化
4. Codex: 应用优化建议

场景2: 问题解决
1. Gemini: 诊断问题，制定方案
2. Codex: 实施修复
3. Gemini: 验证修复效果

场景3: 自动化流程
1. Gemini: 设计自动化流程
2. Codex: 编写自动化脚本
3. Gemini: 测试和优化流程
```

---

## 💰 成本说明

- Gemini 使用 Google Gemini 3 Pro 模型
- 适合各类任务，性价比高
- 复杂任务可能需要更多时间，但会确保完成

---

## 🌐 代理配置

### 中国地区用户
```bash
# 设置环境变量
export HTTP_PROXY=http://127.0.0.1:7890
export HTTPS_PROXY=http://127.0.0.1:7890

# 或在调用时指定
HTTP_PROXY=http://127.0.0.1:7890 gemini -o stream-json <<'EOF'
...
EOF
```

---

## 🎉 总结

**Gemini = 全能型 AI 助手**

- 🎯 **核心理念**: 想尽一切办法完成任务
- 💪 **能力覆盖**: 代码、设计、分析、调试、优化...
- 🧠 **智能决策**: 自动选择最佳策略
- 🔄 **自适应**: 遇到障碍自动调整
- ✅ **可靠性**: 持续尝试直到成功

**使用场景**: 任何需要 AI 帮助的任务

**核心承诺**: 交给 Gemini，它会想办法完成

---

**版本**: 2.0.0
**类型**: 全能型智能助手
**状态**: 生产就绪 ✅
